<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2 C 语言拾遗 | CS Wiki</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="shachi 的 CS 知识库">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.40ef89a5.css" as="style"><link rel="preload" href="/wiki/assets/js/app.8bcba5cc.js" as="script"><link rel="preload" href="/wiki/assets/js/2.4b7299de.js" as="script"><link rel="preload" href="/wiki/assets/js/33.97a174a8.js" as="script"><link rel="preload" href="/wiki/assets/js/3.3ed400f8.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.023c6faa.js"><link rel="prefetch" href="/wiki/assets/js/11.1220b815.js"><link rel="prefetch" href="/wiki/assets/js/12.d1f349ae.js"><link rel="prefetch" href="/wiki/assets/js/13.4279d270.js"><link rel="prefetch" href="/wiki/assets/js/14.0ef11da2.js"><link rel="prefetch" href="/wiki/assets/js/15.0cac3fa4.js"><link rel="prefetch" href="/wiki/assets/js/16.eb5458ee.js"><link rel="prefetch" href="/wiki/assets/js/17.58c9759b.js"><link rel="prefetch" href="/wiki/assets/js/18.44db387a.js"><link rel="prefetch" href="/wiki/assets/js/19.23472cad.js"><link rel="prefetch" href="/wiki/assets/js/20.dcb264c7.js"><link rel="prefetch" href="/wiki/assets/js/21.5a22afeb.js"><link rel="prefetch" href="/wiki/assets/js/22.2dd6b328.js"><link rel="prefetch" href="/wiki/assets/js/23.014c43a0.js"><link rel="prefetch" href="/wiki/assets/js/24.b38bddd1.js"><link rel="prefetch" href="/wiki/assets/js/25.5db6c161.js"><link rel="prefetch" href="/wiki/assets/js/26.249ed6bd.js"><link rel="prefetch" href="/wiki/assets/js/27.c3efab24.js"><link rel="prefetch" href="/wiki/assets/js/28.f263b4e2.js"><link rel="prefetch" href="/wiki/assets/js/29.de8bb10c.js"><link rel="prefetch" href="/wiki/assets/js/30.aa517f4a.js"><link rel="prefetch" href="/wiki/assets/js/31.ae705d65.js"><link rel="prefetch" href="/wiki/assets/js/32.c1702b2c.js"><link rel="prefetch" href="/wiki/assets/js/34.199464e0.js"><link rel="prefetch" href="/wiki/assets/js/35.68a2516c.js"><link rel="prefetch" href="/wiki/assets/js/36.6af7ec02.js"><link rel="prefetch" href="/wiki/assets/js/37.44ebe121.js"><link rel="prefetch" href="/wiki/assets/js/38.bb21ebab.js"><link rel="prefetch" href="/wiki/assets/js/39.1336e262.js"><link rel="prefetch" href="/wiki/assets/js/4.2e33d51d.js"><link rel="prefetch" href="/wiki/assets/js/40.dfd77a0c.js"><link rel="prefetch" href="/wiki/assets/js/41.574325a9.js"><link rel="prefetch" href="/wiki/assets/js/42.fd345137.js"><link rel="prefetch" href="/wiki/assets/js/43.8f685187.js"><link rel="prefetch" href="/wiki/assets/js/44.38e57f01.js"><link rel="prefetch" href="/wiki/assets/js/45.6519eed9.js"><link rel="prefetch" href="/wiki/assets/js/46.e82acc72.js"><link rel="prefetch" href="/wiki/assets/js/47.3f12e556.js"><link rel="prefetch" href="/wiki/assets/js/48.8892b183.js"><link rel="prefetch" href="/wiki/assets/js/49.bd231307.js"><link rel="prefetch" href="/wiki/assets/js/5.5b3fd24d.js"><link rel="prefetch" href="/wiki/assets/js/50.8b5f29ac.js"><link rel="prefetch" href="/wiki/assets/js/51.58b16a46.js"><link rel="prefetch" href="/wiki/assets/js/52.7d84e37f.js"><link rel="prefetch" href="/wiki/assets/js/53.eb63b273.js"><link rel="prefetch" href="/wiki/assets/js/54.6a30aff4.js"><link rel="prefetch" href="/wiki/assets/js/55.c2a2d30c.js"><link rel="prefetch" href="/wiki/assets/js/56.e5faf079.js"><link rel="prefetch" href="/wiki/assets/js/57.a3f5f95e.js"><link rel="prefetch" href="/wiki/assets/js/58.12196dbc.js"><link rel="prefetch" href="/wiki/assets/js/59.e5002e0d.js"><link rel="prefetch" href="/wiki/assets/js/6.3b848e60.js"><link rel="prefetch" href="/wiki/assets/js/60.99ef1bc5.js"><link rel="prefetch" href="/wiki/assets/js/61.f612b4ff.js"><link rel="prefetch" href="/wiki/assets/js/62.2b14fb62.js"><link rel="prefetch" href="/wiki/assets/js/63.eda73af3.js"><link rel="prefetch" href="/wiki/assets/js/64.07154a8d.js"><link rel="prefetch" href="/wiki/assets/js/7.c67aa8fa.js"><link rel="prefetch" href="/wiki/assets/js/8.39a9bf08.js"><link rel="prefetch" href="/wiki/assets/js/9.882008db.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.40ef89a5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><img src="/wiki/favicon.ico" alt="CS Wiki" class="logo"> <span class="site-name can-hide">CS Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link router-link-active">
  C
</a></div><div class="nav-item"><a href="/wiki/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/shell.html" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/gdb.html" class="nav-link">
  gdb
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/CMake.html" class="nav-link">
  CMake
</a></li><li class="dropdown-subitem"><a href="https://github.com/chunni98/learn-python-with-lxf" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Python3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/collections.html" class="nav-link">
  问题集
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/learn-arm.html" class="nav-link">
  ARM 体系结构
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/driver/" class="nav-link">
  Linux 内核驱动
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link router-link-active">
  C
</a></div><div class="nav-item"><a href="/wiki/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/shell.html" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/gdb.html" class="nav-link">
  gdb
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/CMake.html" class="nav-link">
  CMake
</a></li><li class="dropdown-subitem"><a href="https://github.com/chunni98/learn-python-with-lxf" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Python3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/collections.html" class="nav-link">
  问题集
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/learn-arm.html" class="nav-link">
  ARM 体系结构
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/driver/" class="nav-link">
  Linux 内核驱动
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/wiki/c/" aria-current="page" class="sidebar-link">C Program Language</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>inbox</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/c/c-style.html" class="sidebar-link">1 简易 C 语言编程规范</a></li><li><a href="/wiki/c/learn-c.html" aria-current="page" class="active sidebar-link">2 C 语言拾遗</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-1-c-语言版本" class="sidebar-link">2.1 C 语言版本</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-2-编译过程" class="sidebar-link">2.2 编译过程</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-3-宏" class="sidebar-link">2.3 宏</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-4-字符串" class="sidebar-link">2.4 字符串</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-5-内存映像" class="sidebar-link">2.5 内存映像</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-6-二进制文件和文本文件" class="sidebar-link">2.6 二进制文件和文本文件</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-7-浮点数的存储" class="sidebar-link">2.7 浮点数的存储</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-8-位域" class="sidebar-link">2.8 位域</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-9-断言" class="sidebar-link">2.9 断言</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-10-变参函数" class="sidebar-link">2.10 变参函数</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-11-内存对齐" class="sidebar-link">2.11 内存对齐</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-12-联合体" class="sidebar-link">2.12 联合体</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-13-register-存储类型" class="sidebar-link">2.13 register 存储类型</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-14-数组指针" class="sidebar-link">2.14 数组指针</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-15-数组名和指针的区别" class="sidebar-link">2.15 数组名和指针的区别</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-16-字节序" class="sidebar-link">2.16 字节序</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-17-位运算取余" class="sidebar-link">2.17  位运算取余</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-18-补码的运算" class="sidebar-link">2.18 补码的运算</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-19-整型提升" class="sidebar-link">2.19 整型提升</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-20-bool-类型" class="sidebar-link">2.20 _Bool 类型</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-21-占位符" class="sidebar-link">2.21 占位符</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-22-输出格式控制" class="sidebar-link">2.22 输出格式控制</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-23-size-t" class="sidebar-link">2.23 size_t</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-24-零长度数组" class="sidebar-link">2.24 零长度数组</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-25-vla-变长数组" class="sidebar-link">2.25 VLA 变长数组</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-26-关于指针的类型定义" class="sidebar-link">2.26 关于指针的类型定义</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-27-目录结构" class="sidebar-link">2.27 目录结构</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-28-static-inline" class="sidebar-link">2.28 static inline</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-29-枚举和宏的区别" class="sidebar-link">2.29 枚举和宏的区别</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-30-c-语言存储类" class="sidebar-link">2.30 C 语言存储类</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-31-标准预定义宏" class="sidebar-link">2.31 标准预定义宏</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#函数名和函数地址" class="sidebar-link">函数名和函数地址</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#const" class="sidebar-link">const</a></li></ul></li><li><a href="/wiki/c/ccollections.html" class="sidebar-link">3 c 问题集</a></li><li><a href="/wiki/c/json-c.html" class="sidebar-link">4 json-c 库使用</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/c/kandrc/" class="sidebar-heading clickable"><span>K&amp;R C</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/c/glibc/" class="sidebar-heading clickable"><span>glibc 学习</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_2-1-c-语言版本"><a href="#_2-1-c-语言版本" class="header-anchor">#</a> 2.1 C 语言版本 <span class="badge warning" style="vertical-align:top;" data-v-ee04238a>TODO</span></h2> <p>TODO: 标准介绍，各标准特性</p> <p>C 语言规范的最大的变化则发生在 C99 规范之中。其后的 C11 虽然也有一些特性，但更多的算是为了与 C++ 同步而引入的新特性。</p> <h3 id="_2-1-1-c-99"><a href="#_2-1-1-c-99" class="header-anchor">#</a> 2.1.1 C 99</h3> <ul><li>增加了对编译器的限制，比如源始码每行要求至少支持到 4095 字节，变量名函数名的要求支持到 63 字节（extern 要求支持到 31）。</li> <li>增强了预处理功能。例如：
<ul><li>宏支持取可变参数 <code>#define Macro(...) __VA_ARGS__</code>。<div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// ##args 表示允许变参部分为空。</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">debug</span><span class="token expression"><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">&quot;[DEBUG]: &quot;</span> <span class="token expression">fmt<span class="token punctuation">,</span> </span><span class="token punctuation">##</span><span class="token expression">args<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">debug</span><span class="token expression"><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> </span><span class="token punctuation">##</span><span class="token expression">__VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token comment">// # 表示将参数字符串化</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">str</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> #i</span></span>
<span class="token comment">// 空格可以连接字符串</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">strcat</span><span class="token expression"><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span> str1 str2</span></span>
<span class="token comment">// ## 还可以用来将两个 token 连接成一个 token</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">link</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> a</span><span class="token punctuation">##</span><span class="token expression">b</span></span>
<span class="token comment">// link(3,5) -&gt; 35</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li>使用宏的时候，允许省略参数，被省略的参数会被扩展成空串。</li> <li>支持//开头的单行注释（这个特性实际上在C89的很多编译器上已经被支持了）</li></ul></li> <li>增加了新关键字 <code>restrict</code>, <code>inline</code>, <code>_Complex</code>, <code>_Imaginary</code>, <code>_Bool</code>，restrict 修饰指针，防止未定义的行为，像编译器保证，某个指针指向的空间，只能从该指针访问。
<ul><li>支持 <code>long long</code>, <code>long double _Complex</code>, <code>float _Complex</code> 等类型</li></ul></li> <li>支持不定长的数组，即数组长度可以在运行时决定，比如利用变量作为数组长度。声明时使用 <code>int a[var]</code> 的形式。不过考虑到效率和实现，不定长数组不能用在全局，或 struct 与 union 。</li> <li>变量声明不必放在语句块的开头，for语句提倡写成for(int i=0;i&lt;100;++i) 的形式，即i只在for语句块内部有效。</li> <li>允许采用 <code>type-name{xx,xx,xx}</code>这样类似C++的构造函数的形式构造匿名的结构体，即复合文字特性。如 <code>(int[]){1,3}</code>,<code>(int){1}</code>，复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。Compound Literals</li> <li>初始化结构体的时候允许对特定的元素赋值，形式为：
<ul><li><code>struct test{int a[3]，b;} foo[] = { [0].a = {1}, [1].a = 2 };</code></li> <li><code>struct test{int a, b, c, d;} foo = { .a = 1, .c = 3, 4, .b = 5 }; // 3,4 是对 .c,.d 赋值的</code></li></ul></li> <li>格式化字符串中，利用 <code>\u</code> 支持 unicode 的字符。</li> <li>支持 16 进制的浮点数的描述。</li> <li>printf, scanf 的格式化串增加了对 long long int 类型的支持。</li> <li>浮点数的内部数据描述支持了新标准，可以使用 #pragma 编译器指令指定。</li> <li>除了已有的 <code>__LINE__</code>和<code>__FILE__</code> 以外，增加了<code>__func__</code>得到当前的函数名。</li> <li>允许编译器化简非常数的表达式。</li> <li>修改了<code>/</code>和<code>%</code>处理负数时的定义，这样可以给出明确的结果，例如在C89中-22 / 7 = -3, -22 % 7 = -1，也可以-22 / 7= -4, -22 % 7 = 6。 而C99中明确为 -22 / 7 = -3, -22 % 7 = -1，只有一种结果。</li> <li>取消了函数返回类型默认为 int 的规定。</li> <li>允许在 struct 的最后定义的数组不指定其长度，写做 <code>[]</code>(flexible array member)柔性数组。</li> <li>const const int i 将被当作 const int i 处理。</li> <li>增加和修改了一些标准头文件，比如定义 bool 的 <code>&lt;stdbool.h&gt;</code> ，定义一些标准长度的int的 <code>&lt;inttypes.h&gt;</code>，定义复数的<code>&lt;complex.h&gt;</code>，定义宽字符的<code>&lt;wctype.h&gt;</code>，类似于泛型的数学函数<code>&lt;tgmath.h&gt;</code>，浮点数相关的<code>&lt;fenv.h&gt;</code>。在<code>&lt;stdarg.h&gt;</code>增加了va_copy用于复制...的参数。<code>&lt;time.h&gt;</code>里增加了struct tmx，对struct tm做了扩展。</li> <li>输入输出对宽字符以及长整数等做了相应的支持。</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;locale.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;wchar.h&gt;</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setlocale</span><span class="token punctuation">(</span>LC_ALL<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 本地化设置</span>

    <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">&quot;宽字符测试&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">wchar_t</span><span class="token operator">*</span> wstr <span class="token operator">=</span> L<span class="token string">&quot;宽字符测试&quot;</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出单（多）字节字符串</span>
    <span class="token function">wprintf</span><span class="token punctuation">(</span>L<span class="token string">&quot;%ls\n&quot;</span><span class="token punctuation">,</span> wstr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出宽字符串</span>

    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="_2-1-2-c11-gnu-c"><a href="#_2-1-2-c11-gnu-c" class="header-anchor">#</a> 2.1.2 C11 &amp; GNU C</h3> <p><strong>过时弃用</strong></p> <p><code>gets()</code>。</p> <p><strong>新语言特性</strong></p> <ol><li>多线程环境（原子对象 <code>_Atomic</code>，线程本地存储 <code>_Thread_local</code>）</li> <li>增强的对齐支持（对齐方式查询 <code>_Alignof</code>，对齐方式加强<code>_Alignas</code>，过对齐类型 <code>Over-aligned types</code>）,用于指定和查询特定对齐方式的类型。(stdalign.h)</li> <li>Unicode 支持。（<code>u/U</code> 字符常量，<code>u8/u/U</code> 字符串字面量）。(uchar.h)</li> <li>泛型选择表达式（<code>_Generic</code>）。</li> <li>无返回值函数。（<code>_Noreturn</code>）</li> <li>匿名结构体和枚举成员（允许在结构体和联合体中定义匿名的成员，这些成员在定义时不指定名称。）。</li> <li>Fine-grained evaluation order（细粒度求值顺序）。</li> <li>延长临时对象的生存期。</li> <li><code>_Static_assert</code>，静态断言,用于在编译时进行静态断言检查。</li> <li>可分析性，限制某些未定义行为潜在执行结果，提升程序的静态语法分析结果。</li> <li>新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</li> <li>新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。</li> <li>删除 gets()，改为 gets_s()，可用 fgets() 替代。</li> <li>新增安全函数（safe functions）家族，如 gets_s,printf_s 和 scanf_s，strcpy_s 和 strcat_s，memcpy_s 和 memmove_s，但并不是标准 C 语言库函数。</li></ol> <p><strong>可选特性的功能测试宏</strong></p> <ul><li><code>__STDC_ANALYZABLE__</code> 指示支持可分析性。</li> <li><code>__STDC_LIB_EXT1__</code> 指示支持边界检查函数。</li> <li><code>__STDC_NO_ATOMICS__</code>指示不支持原子对象与原子操作库。</li> <li><code>__STDC_NO_COMPLEX__</code>指示不支持复数类型与复数数学函数。这些特性在 C99 中为强制。</li> <li><code>__STDC_NO_THREADS__</code>指示不支持线程局部存储与线程支持库。</li> <li><code>__STDC_NO_VLA__</code> 指示不支持非常量长度数组与可变修改类型。这些特性在 C99 中为强制。</li></ul> <p><strong>库特性</strong></p> <p>新头文件：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token operator">&lt;</span>stdalign<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>stdatomic<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>stdnoreturn<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>threads<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>uchar<span class="token punctuation">.</span>H<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p>并发支持库（<code>threads.h</code>）</p></li> <li><p>_Noreturn 关键字：引入了 _Noreturn 关键字，用于指示函数不会返回。</p></li> <li><p>泛型宏_Generic 关键字：引入了 _Generic 关键字，用于实现基于类型的泛型编程。</p></li> <li><p>Unicode 支持：C11 增强了对 Unicode 字符和字符串的支持，包括 Unicode 转义序列和宽字符字符串常量。</p></li> <li><p>对函数指针的限制放宽：C11 放宽了对函数指针的限制，允许将函数指针转换为其他类型的指针，并且允许将函数指针转换为 void* 类型的指针。</p></li> <li><p>新的库函数：C11 引入了一些新的标准库函数，包括对泛型编程的支持函数 tgmath.h、字符串安全版本的库函数 strlcpy()、strlcat() 等。</p></li></ul> <p><code>_Noreturn</code> 使用：</p> <p>使用 _Noreturn 关键字的目的是帮助编译器进行更好的优化，因为它提供了关于函数行为的额外信息。编译器可以在知道函数不会返回时进行一些优化，例如消除不可达代码或生成更高效的代码。</p> <p>_Noreturn 并非强制性的，它只是一种提示。编译器不会强制要求函数永远不会返回，但是如果函数实际上返回了，编译器可能会发出警告。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">extern</span> <span class="token keyword">_Noreturn</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">_Noreturn</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdnoreturn.h&gt;</span></span>

noreturn <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">quick_exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><code>_Generic</code> :</p> <p>语法规则：<code>_Generic(expression, type1: result1, type2: result2, ..., default: result_default)</code></p> <p><code>_Generic</code> 表达式的求值规则如下：</p> <p>对于给定的 expression，首先根据 type1、type2 等类型标签的顺序，找到与 expression 类型匹配的第一个类型标签。</p> <p>如果找到了匹配的类型标签，则返回对应的结果表达式。</p> <p>如果没有找到匹配的类型标签，则返回默认结果表达式。</p> <p>sample:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">print_type</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">_Generic</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">int</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">&quot;Type: int\n&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">float</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">&quot;Type: float\n&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">double</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">&quot;Type: double\n&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">default</span><span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">&quot;Unknown type\n&quot;</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span>

    <span class="token function">print_type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Type: int</span>
    <span class="token function">print_type</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Type: float</span>
    <span class="token function">print_type</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Unknown type</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><code>static_assert</code> 宏：</p> <p>_Static_assert 关键字和 static_assert 宏均在编译时测试软件断言。 它们可用于全局或函数范围。</p> <p>相反，assert 宏、_assert 和 _wassert 函数在运行时测试软件断言，并产生运行时成本。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// requires /std:c11 or higher</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>

<span class="token keyword">enum</span> <span class="token class-name">Items</span>
<span class="token punctuation">{</span>
    A<span class="token punctuation">,</span>
    B<span class="token punctuation">,</span>
    C<span class="token punctuation">,</span>
    LENGTH
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// _Static_assert is a C11 keyword</span>
    <span class="token keyword">_Static_assert</span><span class="token punctuation">(</span>LENGTH <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;Expected Items enum to have three elements&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Preferred: static_assert maps to _Static_assert and is compatible with C++</span>
    <span class="token function">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&quot;Expecting 32 bit integers&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p><strong>GNU C case 范围</strong></p> <p>支持：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">case</span> low <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> high
<span class="token keyword">case</span> <span class="token char">'A'</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token char">'Z'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>例：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token char">'0'</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token char">'7'</span><span class="token operator">:</span>
        val <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">+</span> name <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token char">'8'</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token char">'9'</span><span class="token operator">:</span>
        val <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">+</span> name <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">return</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>注意：<code>...</code> 两边要用空格，否则会出错。</p> <p><strong>GNU C typeof</strong></p> <p>例子：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">max</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">typeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> _a <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">typeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> _b <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_a <span class="token operator">==</span> <span class="token operator">&amp;</span>_b<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>
    <span class="token expression">_a <span class="token operator">&gt;</span> _b <span class="token operator">?</span> _a <span class="token operator">:</span> _b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>(void) (&amp;_a == &amp;_b)</code> 判断两个数类型是否相同，如果不同，会抛出警告。</p> <p><strong>标号初始化</strong></p> <p>GNU C 语言可以通过指定索引或结构体成员名来初始化，不必按照原来固定的顺序来进行初始化。</p> <p>例子：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> zero_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> my_open
    <span class="token punctuation">.</span>read <span class="token operator">=</span> my_read
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这种初始化方法能保证已知元素的正确性，对于未初始化成员的值为 0 或者为 NULL。</p> <h2 id="_2-2-编译过程"><a href="#_2-2-编译过程" class="header-anchor">#</a> 2.2 编译过程</h2> <p><code>gcc x.c</code> 默认的产物是 <code>a.out</code>，assembler output 的缩写。</p> <h3 id="_2-2-1-预处理"><a href="#_2-2-1-预处理" class="header-anchor">#</a> 2.2.1 预处理</h3> <p>调用预处理器<code>cpp</code>，完成宏展开、头文件包含、处理条件编译、删除注释等工作。</p> <p><strong>预处理指令</strong></p> <ol><li><code>#error error message</code>，<code>#error</code> 预处理指令的作用是，编译程序时，只要遇到#error 就会生成一个编译错误提示消息，并停止编译。</li> <li><code>#warning warning message</code>。(c23)</li> <li><code>#define</code></li> <li><code>#elif</code></li> <li><code>#else</code></li> <li><code>endif</code></li> <li><code>if</code></li> <li><code>ifdef</code></li> <li><code>ifndef</code></li> <li><code>import</code>（C++），过去一直合并类型库中的信息。 类型库的内容将转换为 C++ 类，主要描述 COM 接口。</li> <li><code>include</code></li> <li><code>line</code></li> <li><code>pragma</code></li> <li><code>undef</code></li> <li><code>using</code>（C++），将元数据导入使用 <code>/clr</code> 编译的程序。</li></ol> <p>例子：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__STDC_NO_ATOMICS__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token string">&quot;不支持 C11 原子操作！&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;inttypes.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;threads.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">add</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> a<span class="token operator">+</span>b</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">a <span class="token operator">==</span> <span class="token number">0</span></span></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;1, a = %d\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">a <span class="token operator">==</span> <span class="token number">2</span></span></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;3, a == %d\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;2, a != %d\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">add</span></span>
    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>一些预定义的宏：</p> <p><code>__DATE__</code> 进行预处理的日期（“Mmm dd yyyy”形式的字符串文字，如May 27 2006）</p> <p><code>__FILE__</code> 代表当前源代码文件名的字符串文字 ，包含了详细路径，如 <code>G:/program/study/c+/test1.c</code></p> <p><code>__LINE__</code> 代表当前源代码中的行号的整数常量</p> <p><code>__TIME__</code> 源文件编译时间，格式微“hh：mm：ss”，如：09:11:10；</p> <p><code>__FUNCTION__</code> 当前所在函数名</p> <p><code>gcc -E -o a.i a.c</code></p> <h3 id="_2-2-2-编译"><a href="#_2-2-2-编译" class="header-anchor">#</a> 2.2.2 编译</h3> <p>调用编译器 <code>cc1</code>，把源程序翻译成目标系统的汇编文件 <code>.s</code>。</p> <p>将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，加工为当前机器支持的汇编代码。</p> <p><code>gcc -S -o a.s a.i</code></p> <h3 id="_2-2-3-汇编"><a href="#_2-2-3-汇编" class="header-anchor">#</a> 2.2.3 汇编</h3> <p>调用汇编器 <code>as</code>，将汇编指令翻译成机器指令，生成可重定位目标文件。</p> <p><code>gcc -o a.o -c a.s</code></p> <h3 id="_2-2-4-链接"><a href="#_2-2-4-链接" class="header-anchor">#</a> 2.2.4 链接</h3> <p>调用链接器 <code>ld</code> ，将生成的可重定位文件与相关库文件链接，生成可执行目标文件。</p> <ol><li>符号分析</li> <li>重定位。（重新分配地址）</li></ol> <p><code>gcc -o a a.o -lm</code></p> <h2 id="_2-3-宏"><a href="#_2-3-宏" class="header-anchor">#</a> 2.3 宏</h2> <p>避免使用宏，尽量使用编译器而不用预处理。</p> <p>多行的宏，需要用下面的结构包围起来：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">do</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>c99 的变参宏</strong></p> <p>宏可以接受可变数目的参数，主要用于在输出函数里，例：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">pr_debug</span><span class="token expression"><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">dynamic_pr_debug</span><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span> </span><span class="token punctuation">##</span><span class="token expression">__VA_ARGS__<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">kdebug</span><span class="token expression"><span class="token punctuation">(</span>fmt<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">printf</span> <span class="token punctuation">(</span>COLOR_BLUE fmt COLOR_NONE<span class="token punctuation">,</span></span><span class="token punctuation">##</span><span class="token expression">args<span class="token punctuation">)</span></span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>__VA_ARGS__</code> 是编译器保留字段，预处理时把参数传递给宏。</p> <p><code>##</code> 可用于连接字符串。</p> <h2 id="_2-4-字符串"><a href="#_2-4-字符串" class="header-anchor">#</a> 2.4 字符串</h2> <p>不要将字符串常量用于非 <code>const</code> 的字符串变量。</p> <p>字符串常量是 <code>const char*</code> 类型。</p> <p>字符数组可以看作 <code>char* const</code> 类型，数组名执行地址不可变，但可以通过指针修改字符串。</p> <h2 id="_2-5-内存映像"><a href="#_2-5-内存映像" class="header-anchor">#</a> 2.5 内存映像</h2> <p>CPU是计算机的核心，决定了计算机的数据处理能力和寻址能力。CPU一个时钟，也就是一次能处理的数据的大小由寄存器的位数和数据总线的宽度决定，通常所说的CPU的32位、64位可以理解为寄存器的位数，也可以理解为数据总线的宽度。</p> <p>​以32位CPU为例子，即一次能处理32Bit，即4个字节的数据。典型的32位处理器是Intel 80386,它的数据总线宽度有32位，地址总线宽度也是32位，寻址能力为2<sup>32</sup> = 4GB</p> <p>数据总线用于在CPU和内存之间传输数据，地址总线用于在内存上定位数据，地址总线的宽度往往随着数据总线的宽度增大而增大，以访问更大的内存。</p> <p>​同时CPU支持的物理内存只是理论上的数据，实际应用中会受到操作系统的限制，比如说win7 64位家庭版最大支支持8GB和16GB的物理内存，win7 64位专业版可以支持到192GB的物理内存。但是32位CPU寻址能力没有这么大，所以要通过两次寻址来实现。</p> <p>所谓的虚拟空间，就是程序可以使用的虚拟地址的有效范围。虚拟地址和物理地址的映射关系由操作系统决定，相应地，虚拟地址空间的大小也由操作系统决定，但还会受到编译模式的影响。</p> <p>windows和Linux都会对虚拟地址进行了限制，仅使用虚拟地址的低48位（6个字节），总的虚拟空间大小位为2<sup>48</sup>=256TB，而且任何虚拟地址的48位至63位必须与47位一致。</p> <p>​如果内存大于物理内存，或者内存中剩余的空间不够容纳当前的程序，那么操作系统会将内存中用不到的一部分数据写入磁盘，等需要的时候再读取回来。程序只管使用4GB的内存，而不用关心硬件资源。</p> <p>32位内存映像如下：</p> <p><img src="/wiki/c/%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F.png" alt=""></p> <p><code>ulimit -s</code> 查看栈空间大小，单位 <code>Mb</code>。</p> <p>c语言五大内存分区</p> <ul><li>栈区（stack）:存放函数形参和局部变量（auto类型），由编译器自动分配和释放（<code>.stack</code>）</li> <li>堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由 OS 回收。（<code>.heap</code>）</li> <li>全局/静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），未初始化的全局变量和静态变量放在一块（<code>.bss</code>），初始化的放在另一块（<code>.data</code>），编译时就分配好了。</li> <li>常量区：只读数据段：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。（<code>.rodata</code>）程序代码段：存放程序的二进制代码，内存由系统管理（<code>.text</code>）</li></ul> <p>其中rodata区和text区在加载时会合并到一个段中，该段称为常量区，该区域的内容只允许读，不允许修改。</p> <p>data 区和bss区在加载时合并到一个段中，该段被称为全局区。</p> <p>bss 段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。 data段（已手动初始化的数据）为数据分配空间，数据保存在目标文件中。</p> <p>data 段包含经过初始化的全局变量以及它们的值。</p> <p>bss 段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区。</p> <p><code>.bss</code>是不占用可执行文件空间的，只占用运行时空间，其内容由操作系统初始化（清零），初始化为 0 的全局变量出于编译优化的策略还是被保存到 bss 段，可通过 nm 命令查看。</p> <p><strong>rodata</strong></p> <p>用 const 修饰的全局变量放在 rodata 里（mm 查看后，可看到是在 R 区），不可以取地址修改，字符串默认就是常量。</p> <p>rodata的意义同样明显，ro代表read only，即只读数据(const)。关于rodata类型的数据，要注意以下几点：</p> <ol><li>常量不一定就放在rodata里，有的立即数直接编码在指令里，存放在代码段(.text)中。</li> <li>对于字符串常量，编译器会自动去掉重复的字符串，保证一个字符串在一个可执行文件(EXE/SO)中只存在一份拷贝。</li> <li>rodata是在多个进程间是共享的，这可以提高空间利用率。</li> <li>在有的嵌入式系统中，rodata放在ROM(如norflash)里，运行时直接读取ROM内存，无需要加载到RAM内存中。</li> <li>在嵌入式linux系统中，通过一种叫作XIP（就地执行）的技术，也可以直接读取，而无需要加载到RAM内存中。由此可见，把在运行过程中不会改变的数据设为rodata类型的，是有很多好处的：在多个进程间共享，可以大大提高空间利用率，甚至不占用RAM空间。同时由于rodata在只读的内存页面(page)中，是受保护的，任何试图对它的修改都会被及时发现，这可以帮助提高程序的稳定性。</li></ol> <p>在64位环境下，虚拟地址空间大小为 256TB，Linux 将高 128TB 的空间分配给内核使用，而将低 128TB 的空间分配给用户程序使用。</p> <p>64位内存空间分布情况如下：</p> <p><img src="/wiki/c/64%E4%BD%8D%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt=""></p> <p>注意：</p> <p>栈一般的增长方向是：高地址向低地址。</p> <p>堆增长方向是：低地址向高地址。</p> <p>这个上下文里说的“栈”是函数调用栈，是以“栈帧”（stack frame）为单位的。每一次函数调用会在栈上分配一个新的栈帧，在这次函数调用结束时释放其空间。</p> <p>被调用函数（callee）的栈帧相对调用函数（caller）的栈帧的位置反映了栈的增长方向：如果被调用函数的栈帧比调用函数的在更低的地址，那么栈就是向下增长；反之则是向上增长。而在一个栈帧内，</p> <p>局部变量是如何分布到栈帧里的（所谓栈帧布局，stack frame layout），这完全是编译器的自由。</p> <p>至于数组元素与栈的增长方向：C与C++语言规范都规定了数组元素是分布在连续递增的地址上的。</p> <p>每个函数都是一个栈帧，栈的分配是按着这个来的，而栈帧里是怎么分配完全看编译器来。</p> <p><img src="/wiki/c/%E6%A0%88%E5%A2%9E%E9%95%BF.png" alt=""></p> <p>内核空间(1G，0xc0000000 ~ 0xffffffff)</p> <p>用户空间(3G, 0x00000000 ~ 0xC0000000)</p> <p>当进程/线程运行在内核空间时就处于内核态，而进程/线程运行在用户空间时则处于用户态。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 递归函数</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">recursive_function</span><span class="token punctuation">(</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> local_variable<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">recursive_function</span><span class="token punctuation">(</span>depth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Address of the local variable: %p\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_variable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">recursive_function</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">// 输出：</span>
<span class="token comment">// Address of the local variable: 00000041619ffa0c    // 栈顶</span>
<span class="token comment">// Address of the local variable: 00000041619ffa4c</span>
<span class="token comment">// Address of the local variable: 00000041619ffa8c</span>
<span class="token comment">// Address of the local variable: 00000041619ffacc</span>
<span class="token comment">// Address of the local variable: 00000041619ffb0c</span>
<span class="token comment">// Address of the local variable: 00000041619ffb4c     // 栈底</span>
<span class="token comment">//</span>
<span class="token comment">// 栈顶指针 &lt; 栈底指针，所以栈的增长方向是高地址向低地址增长。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="_2-6-二进制文件和文本文件"><a href="#_2-6-二进制文件和文本文件" class="header-anchor">#</a> 2.6 二进制文件和文本文件</h2> <p>数据在物理上的存储方式是二进制的，即由0/1字符串构成。而我们解读这些的方式有两种：基于字符编码，和基于值编码。</p> <h3 id="_2-6-1-基于字符编码"><a href="#_2-6-1-基于字符编码" class="header-anchor">#</a> 2.6.1 基于字符编码</h3> <p>即每个我们肉眼可读的字符都有唯一对应的0/1字符串，我们读、写这些字符都使用同一套编码方式。</p> <p>如果某文件的数据使用基于字符的编码，那么该文件即为“文本文件”。</p> <p>文本文件则在二进制的基础上，进行了字符编码，因此，我们看到的诸如 .txt 以及程序文件都是字符形式。</p> <p>常见的基于字符的编码有：ASCII码，Unicode编码。</p> <h3 id="_2-6-2-基于值编码"><a href="#_2-6-2-基于值编码" class="header-anchor">#</a> 2.6.2 基于值编码</h3> <p>可以理解为自定义的编码。</p> <p>如果某文件的数据使用基于值的编码，那么该文件即为“二进制文件”。不同的应用程序对二进制文件中的每个值会有不同的解读，就像不同的编码对文本文件中的每一/多个字节有不同的解读。</p> <p>常见的二进制文件有可执行程序、图形、图像、声音等等。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">&quot;./data.dat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;w+b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>fp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">19</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fwrite</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">&quot;./dat.dat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;w+b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>fp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 基于字符编码</span>
<span class="token comment">// $ hexdump -C dat.dat</span>
<span class="token comment">// 00000000  31 33 35 37 39 31 31 31  33 31 35 31 37 31 39     |135791113151719|</span>
<span class="token comment">// 0000000f</span>
<span class="token comment">//</span>
<span class="token comment">// 基于值编码</span>
<span class="token comment">// $ hexdump -C data.dat</span>
<span class="token comment">// 00000000  01 00 00 00 03 00 00 00  05 00 00 00 07 00 00 00  |................|</span>
<span class="token comment">// 00000010  09 00 00 00 0b 00 00 00  0d 00 00 00 0f 00 00 00  |................|</span>
<span class="token comment">// 00000020  11 00 00 00 13 00 00 00                           |........|</span>
<span class="token comment">// 00000028</span>


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><h2 id="_2-7-浮点数的存储"><a href="#_2-7-浮点数的存储" class="header-anchor">#</a> 2.7 浮点数的存储</h2> <p>32位下的浮点数存储：</p> <p>符号位 1 + 指数位（8）+小数位（24）</p> <p>IEEE754规定, 指数位用于表示[-127, 128]范围内的指数</p> <p>规定: 在32位单精度类型中, 这个偏移量是127. 在64位双精度类型中, 偏移量是1023. 所以, 这里的偏移量是127。</p> <p>有了偏移量, 指数位中始终都是一个非负整数。</p> <h2 id="_2-8-位域"><a href="#_2-8-位域" class="header-anchor">#</a> 2.8 位域</h2> <p>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。</p> <p>在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">bs</span><span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> m<span class="token punctuation">;</span>
    <span class="token class-name">uint32_t</span> n <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> ch <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>都定义为 <code>unsigned</code> 类型。</p> <p>位域技术就是在成员变量所占用的内存中选出一部分位宽来存储数据。</p> <p>C99规定int、unsigned int和 _Bool 可以作为位域类型，但编译器几乎都对此作了扩展。</p> <ol><li>如果一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</li></ol> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">bs</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> a<span class="token operator">:</span><span class="token number">4</span>
    <span class="token keyword">unsigned</span> <span class="token operator">:</span><span class="token number">0</span> <span class="token comment">/*空域*/</span>
    <span class="token keyword">unsigned</span> b<span class="token operator">:</span><span class="token number">4</span> <span class="token comment">/*从下一单元开始存放*/</span>
    <span class="token keyword">unsigned</span> c<span class="token operator">:</span><span class="token number">4</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>空域用 0 填充单元剩下的空间。</p> <ol start="2"><li>位域的长度不能大于数据类型本身的长度，比如int类型就能超过32位二进位。</li> <li>位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。</li></ol> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">k</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token operator">:</span><span class="token number">1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">:</span><span class="token number">2</span> <span class="token comment">/*该2位不能使用*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> b<span class="token operator">:</span><span class="token number">3</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> c<span class="token operator">:</span><span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用位域的主要目的是压缩存储，其大致规则为：</p> <ol><li><p>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止</p></li> <li><p>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</p></li> <li><p>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，tdm-gcc，GCC采取压缩方式；</p></li> <li><p>如果位域字段之间穿插着非位域字段，则不进行压缩.</p></li> <li><p>整个结构体的总大小为最宽基本类型成员大小的整数倍。</p></li></ol> <h2 id="_2-9-断言"><a href="#_2-9-断言" class="header-anchor">#</a> 2.9 断言</h2> <p><code>assert</code>宏的原型定义在<code>assert.h</code>中，其作用是如果它的条件返回错误，则终止程序执行。</p> <p><code>assert</code>的作用是现计算表达式 <code>expression</code> ，如果其值为假（即为0），那么它先向 <code>stderr</code> 打印一条出错信息,然后通过调用 <code>abort</code> 来终止程序运行。</p> <p>通过 <code>NDEBUG</code> 宏关闭，在调试结束后，可以通过在包含 <code>#include</code> 的语句之前插入 <code>#define NDEBUG</code> 来禁用 <code>assert</code> 调用。</p> <p><code>gcc -DNDEBUG</code></p> <p><code>assert</code> 的缺点是，频繁调用会极大的影响程序的性能，增加额外的开销。</p> <h3 id="_2-9-1-用法总结与注意事项"><a href="#_2-9-1-用法总结与注意事项" class="header-anchor">#</a> 2.9.1 用法总结与注意事项</h3> <p><strong>1. 在函数开始处检验传入参数的合法性</strong></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">resetBufferSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> nNewSize<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">//功能:改变缓冲区大小,</span>
<span class="token comment">//参数:nNewSize 缓冲区新长度</span>
<span class="token comment">//返回值:缓冲区当前长度</span>
<span class="token comment">//说明:保持原信息内容不变 nNewSize&lt;=0表示清除缓冲区</span>
<span class="token function">assert</span><span class="token punctuation">(</span>nNewSize <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">assert</span><span class="token punctuation">(</span>nNewSize <span class="token operator">&lt;=</span> MAX_BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>2. 每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败</strong></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// bad:</span>
<span class="token function">assert</span><span class="token punctuation">(</span>nOffset<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nOffset<span class="token operator">+</span>nSize<span class="token operator">&lt;=</span>m_nInfomationSize<span class="token punctuation">)</span><span class="token punctuation">;</span> 　
　
<span class="token comment">// good:</span>
<span class="token function">assert</span><span class="token punctuation">(</span>nOffset <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">assert</span><span class="token punctuation">(</span>nOffset<span class="token operator">+</span>nSize <span class="token operator">&lt;=</span> m_nInfomationSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>3. assert和后面的语句应空一行,以形成逻辑和视觉上的一致感</strong></p> <p><strong>4. 有的地方,assert不能代替条件过滤</strong></p> <p>程序一般分为Debug 版本和Release 版本，Debug 版本用于内部调试，Release 版本发行给用户使用。
断言assert 是仅在Debug 版本起作用的宏，它用于检查&quot;不应该&quot;发生的情况。以下是一个内存复制程序，
在运行过程中，如果assert 的参数为假，那么程序就会中止。</p> <p>使用断言的原则：</p> <ol><li>使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。</li> <li>使用断言对函数的参数进行确认。</li> <li>在编写函数时，要进行反复的考查，并且自问：&quot;我打算做哪些假定？&quot;一旦确定了的假定，就要使用断言对假定进行检查。</li> <li>一般教科书都鼓励程序员们进行防错性的程序设计，但要记住这种编程风格会隐瞒错误。当进行防错性编程时，如果&quot;不可能发生&quot;的事情的确发生了，则要使用断言进行报警。</li></ol> <h2 id="_2-10-变参函数"><a href="#_2-10-变参函数" class="header-anchor">#</a> 2.10 变参函数 <span class="badge warning" style="vertical-align:top;" data-v-ee04238a>TODO</span></h2> <p>TODO: 补充</p> <h2 id="_2-11-内存对齐"><a href="#_2-11-内存对齐" class="header-anchor">#</a> 2.11 内存对齐</h2> <p>(1) 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p> <p>(2) 平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p> <p>(3) 空间原因：没有进行内存对齐的结构体或类会浪费一定的空间，当创建对象越多时，消耗的空间越多。</p> <p>如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p> <p>在设置结构体或类时，不考虑内存对齐问题，会浪费一些空间。</p> <p>对齐规则：</p> <ol><li>struct内部每个成员按自身大小对齐，起始地址是自身宽度的整数倍。</li> <li>struct末尾紧贴着一个相同类型的struct，也能够使下一个struct内成员对齐。</li> <li>填充的值为垃圾值，非空。</li></ol> <p>永远不要用 <code>pragma pack</code>。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>push<span class="token punctuation">)</span> </span><span class="token comment">// 保存当前的对齐方式</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    <span class="token keyword">short</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>结构体对齐原则</strong></p> <ol><li>填充的值非空，为垃圾值。</li> <li>按成员中占内存最多的数据类型字节数对齐。</li> <li>每个成员起始位置一定是自己宽度的整数倍。</li> <li>结构体变量占字节数必须是最宽成员数据类型的整数倍。</li></ol> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">st</span><span class="token punctuation">{</span>
    <span class="token keyword">double</span>  a<span class="token punctuation">;</span>  <span class="token comment">// 8</span>
    <span class="token class-name">int16_t</span> b<span class="token punctuation">;</span>  <span class="token comment">// 2</span>
    <span class="token class-name">int32_t</span> c<span class="token punctuation">;</span>  <span class="token comment">// 4</span>
    <span class="token class-name">int8_t</span>  d<span class="token punctuation">;</span>  <span class="token comment">// 1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">st</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">24</span> Bytes<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_2-12-联合体"><a href="#_2-12-联合体" class="header-anchor">#</a> 2.12 联合体</h2> <p>联合体大小是以所占空间最大的为标准分配空间。</p> <h2 id="_2-13-register-存储类型"><a href="#_2-13-register-存储类型" class="header-anchor">#</a> 2.13 register 存储类型</h2> <p>直接存在 CPU 的寄存器中。</p> <h2 id="_2-14-数组指针"><a href="#_2-14-数组指针" class="header-anchor">#</a> 2.14 数组指针</h2> <p>对二维数组的定义，第一维的长度是可以缺省的，但是第二维不可缺省。</p> <p>对数组取地址，指针类型就是数组指针。</p> <p><code>int arr[][4] = {0};</code></p> <p><code>int (*p)[4] = arr</code></p> <h2 id="_2-15-数组名和指针的区别"><a href="#_2-15-数组名和指针的区别" class="header-anchor">#</a> 2.15 数组名和指针的区别</h2> <p>数组名的含义：</p> <ol><li>数组在内存空间的名称。</li> <li>数组的起始地址。</li></ol> <p>区别一：</p> <ol><li>对数组名取地址得到的是数组所指元素的地址，但类型是数组指针。</li> <li>对指针取地址得到的是指针变量自身的地址。</li></ol> <p>区别二：</p> <ol><li>数组名是常量指针。</li> <li>指针是变量指针。</li></ol> <p>区别三：</p> <ol><li><code>sizfof(数组名)</code> 得到的整个数组的字节数。</li> <li><code>sizeof(指针)</code> 得到的是指针类型的字节数。</li></ol> <p>指针的访问效率远远高于数组名的访问效率。</p> <p>对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关。</p> <p>当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p> <h2 id="_2-16-字节序"><a href="#_2-16-字节序" class="header-anchor">#</a> 2.16 字节序</h2> <p>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。</p> <p>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p> <p>字节序是由 CPU 决定的。</p> <p>对于多字节的数据，在内存中存储时，存放字节的顺序为字节序。</p> <p>大端序</p> <p>高位放在低地址，低位放在高地址。</p> <p>小端序。</p> <p>高位放在高地址，地位放在低地址。</p> <p>判断字节序：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

   <span class="token keyword">union</span><span class="token punctuation">{</span>
       <span class="token class-name">int32_t</span> n<span class="token punctuation">;</span>
       <span class="token class-name">int8_t</span> ch<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>data<span class="token punctuation">;</span>

    data<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">0x00000001</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>ch <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;小端序\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;大端序\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_2-17-位运算取余"><a href="#_2-17-位运算取余" class="header-anchor">#</a> 2.17  位运算取余</h2> <p>位运算适用于除数是 2<sup>n</sup></p> <p>的情况。对 2<sup>n</sup></p> <p>取余，就预示着数字向右移 n 位，这右移的 n 位就是余数。</p> <h2 id="_2-18-补码的运算"><a href="#_2-18-补码的运算" class="header-anchor">#</a> 2.18 补码的运算</h2> <p>补码减法运算的公式： <code>[ x －y ] 补＝ [ x ] 补－ [ y ] 补＝ [ x ] 补＋ [ －y ] 补</code></p> <h2 id="_2-19-整型提升"><a href="#_2-19-整型提升" class="header-anchor">#</a> 2.19 整型提升</h2> <p>在 <code>K&amp;R</code> 和 <code>C89</code> 的早期实现中，基于 <code>short</code> 和 <code>char</code> 的算术运算陷入两难的困境，因为可能会产生两种不同的结果。因此，在C99中很明确地定义了整型提升的规则. 如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被转成 <code>unsigned int</code> 型。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。</p> <p>表达式中的字符型和短整型操作数在使用之前被转换为普通类型，这种转换称为整形提升。</p> <p><code>char</code> 和 <code>short</code> 在参与运算时，均是先转换为 <code>int</code> 再进行。</p> <p>通常情况下，在对int类型的数值作运算时，CPU的运算速度是最快的。在x86上，32位算术运算的速度比16位算术运算的速度快一倍。C语言是一个注重效率的语言，所以它会作整型提升，使得程序的运行速度尽可能地快。</p> <h2 id="_2-20-bool-类型"><a href="#_2-20-bool-类型" class="header-anchor">#</a> 2.20 _Bool 类型</h2> <p>C99 中，提供了 <code>_Bool</code> 类型，<code>_Bool</code> 只能赋值为 0 或 1，非 0 的值都会被存储为 1。</p> <h2 id="_2-21-占位符"><a href="#_2-21-占位符" class="header-anchor">#</a> 2.21 占位符</h2> <ul><li><code>%c</code>：字符。</li> <li><code>%d</code>：十进制整数。</li> <li><code>%u</code>: 无符号整型</li> <li><code>%e</code>：使用科学计数法的浮点数，指数部分的e为小写。</li> <li><code>%E</code>：使用科学计数法的浮点数，指数部分的E为大写。</li> <li><code>%i</code>：整数，可读取非十进制整数。</li> <li><code>%f</code>：小数（包含float类型和double类型）。</li> <li><code>%g</code>：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的e为小写。</li> <li><code>%G</code>：等同于%g，唯一的区别是指数部分的E为大写。</li> <li><code>%hd</code>：十进制 short int 类型。</li> <li><code>%ho</code>：八进制 short int 类型。</li> <li><code>%hx</code>：十六进制 short int 类型。</li> <li><code>%hu</code>：unsigned short int 类型。</li> <li><code>%ld</code>：十进制 long int 类型。</li> <li><code>%lo</code>：八进制 long int 类型。</li> <li><code>%lx</code>：十六进制 long int 类型。</li> <li><code>%lu</code>：unsigned long int 类型。</li> <li><code>%lld</code>：十进制 long long int 类型。</li> <li><code>%llo</code>：八进制 long long int 类型。</li> <li><code>%llx</code>：十六进制 long long int 类型。</li> <li><code>%llu</code>：unsigned long long int 类型。</li> <li><code>%Le</code>：科学计数法表示的 long double 类型浮点数。</li> <li><code>%Lf</code>：long double 类型浮点数。</li> <li><code>%lf</code>: double</li> <li><code>%n</code>：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。</li> <li><code>%o</code>：八进制整数。</li> <li><code>%p</code>：指针。</li> <li><code>%s</code>：字符串。</li> <li><code>%u</code>：无符号整数（unsigned int）。</li> <li><code>%x</code>：十六进制整数。</li> <li><code>%zu</code>：<code>size_t</code>类型。</li> <li><code>%zd</code>: <code>ssize_t</code> 类型。</li> <li><code>%td</code>: ptrdiff_t 类型。</li> <li><code>%%</code>：输出一个百分号。</li> <li><code>%lc</code>：打印宽字符。</li> <li><code>%ls</code>：打印宽字符串。</li></ul> <p><code>%c</code> 和 <code>%hhd</code> 区别：二者针对类型都是单字节整数，也就是<code>char</code>或者<code>unsigned char</code>。不过<code>%c</code>在输入输出的时候，是按照字符操作的。<code>%hhd</code>是按照整数操作。</p> <h2 id="_2-22-输出格式控制"><a href="#_2-22-输出格式控制" class="header-anchor">#</a> 2.22 输出格式控制</h2> <ul><li><code>-</code>：字段宽度内左对齐。</li> <li><code>+</code>：显示正负号。</li> <li><code>#</code>：输出进制前缀。</li> <li><code>0</code>：填充0，指定宽度内。</li> <li><code>[num]</code>：指定宽度，超过不截断，少的用空格填充。</li> <li><code>*</code>：待指定宽度，第一个参数为宽度。</li> <li><code>.[num]</code>：精度，不够用 0 填充（写入数字最小位数，对于 <code>e</code>、<code>f</code>，指定小数位数。对于 <code>s</code>，指定输出最大字符数。</li> <li><code>.*</code>：待指定精度，第一个参数为精度。</li></ul> <h2 id="_2-23-size-t"><a href="#_2-23-size-t" class="header-anchor">#</a> 2.23 size_t</h2> <p><code>sizeof</code> 操作符的返回结果类型是 <code>size_t</code>，在程序设计的时候，如果处理 <code>size_t</code> ，占位符需要为 <code>%zu</code>，如果是 <code>ssize_t</code> ，则需要用 <code>%zd</code>。</p> <p><code>size_t</code> 表示 C 中任何对象所能达到的最大长度。</p> <p>在声明注入字符数或者数组索引这样的长度变量时用 <code>size_t</code> 是最好的做法，它经常用于循环计数器、数组索引。</p> <p>如：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">99</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>使用 <code>size_t</code> 需包含头文件 <code>&lt;stddef.h&gt;</code></p> <h2 id="_2-24-零长度数组"><a href="#_2-24-零长度数组" class="header-anchor">#</a> 2.24 零长度数组 <span class="badge warning" style="vertical-align:top;" data-v-ee04238a>TODO</span></h2> <p>又叫做柔性数组，它的主要作用就是为了满足需要变长度的结构体，因此有时也习惯地称为变长数组。</p> <p>主要用途：变长的报文和字符串处理，为了解决冗余和数组越界问题，和指针相比并不占空间，且不需要二次访存，效率高。</p> <p>用法：必须在一个结构体的最后，声明一个长度为 0 的数组，就可以使这个结构体是可变长的。</p> <p>此时长度为 0 的数组并不占用空间，因为数组名本身不占空间，只是一个偏移量，数组名
这个符号本身代表了一个不可修改的地址常量。</p> <p>例子：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">line</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">length</span><span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//uint64_t contents[0]</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">line</span> <span class="token operator">*</span>thisline <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">line</span><span class="token punctuation">)</span> <span class="token operator">+</span> this_length<span class="token punctuation">)</span><span class="token punctuation">;</span>
thisline<span class="token operator">-&gt;</span>length <span class="token operator">=</span> his_length<span class="token punctuation">;</span>

<span class="token keyword">enum</span> <span class="token punctuation">{</span>
    LENGTH <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>SoftArray<span class="token punctuation">;</span>

softArray <span class="token operator">=</span> <span class="token punctuation">(</span>SoftArray<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>SoftArray<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 销毁时直接 free()</span>
<span class="token function">free</span><span class="token punctuation">(</span>softArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><code>struct line</code> 数据结构大小只包含 <code>int</code> 类型的大小，不包含 <code>contents</code> 的大小。</p> <p>也就是 <code>sizeof(struct line) = sizeof(int)</code>。</p> <p>网络通信协议： 在网络编程中，柔性数组可以用来表示数据包的可变部分。例如，一个网络通信协议的数据包可能包括一个固定的头部和一个可变长度的数据部分，柔性数组可以用来存储数据部分。</p> <p>文件格式： 在创建自定义文件格式时，柔性数组可用于表示文件中的可变大小的数据块。这允许您将多个数据块存储在一个文件中，每个数据块的大小可以不同。</p> <p>数据库系统： 数据库系统中的记录通常具有固定的结构，但有时需要存储可变数量的数据项。柔性数组可以用于在记录中存储可变数量的数据。</p> <p>解析器和编译器： 在编写解析器或编译器时，柔性数组可用于存储语法树节点或中间代码表示中的可变数量的子节点。</p> <h2 id="_2-25-vla-变长数组"><a href="#_2-25-vla-变长数组" class="header-anchor">#</a> 2.25 VLA 变长数组</h2> <p>尽量不要使用 VLA，可通过：<code>gcc -Wvla</code> 检测，C++ 不支持。</p> <p>在 c11 之后是可选的。</p> <p>可通过宏 <code>__STDC_NO_VLA__</code> 检测：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">__STDC_NO_VLA__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token string">&quot;不支持 C99 VLA&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>变长数组的实现默认是通过动态设置栈顶来实现的。</p> <p>变长数组允许不在栈上，有些编译器可能用 <code>malloc</code> 实现。</p> <p>VLA目前在 MSVC/GCC 上的实现全部都是利用到了alloca() ，在栈上动态申请一块内存（移动栈指针），
当函数返回时，栈指针回归外一层函数时的状态，因而alloca() 分配的内存得以释放。</p> <p>实际工程中不推荐使用VLA。原因如下：若数组长度很大，有造成爆栈的危险。OS给进程的栈的大小是有限的。</p> <p>使用alloca()后会造成部分与栈操作有关的编译器优化失效。因此，若数组长度有可能很大，请直接在堆上分配避免爆栈。</p> <p>vla 不支持初始化。</p> <p>C99中对对VLA有一些限制，比如变长数组必须是自动存储类型，也就是说，如果我上面两句放在函数外面就就
不能通过编译了，这是因为在函数外面定义的是全局变量，此外，使用VLA不能对数组进行初始化，因为它的
长度在运行时才能确定。</p> <p>VLA并不是真正的变长，它实际上只是将数组的长度推迟到运行时确定而已，也就是说C90标准中，
数组的长度必须在编译时期就知道，但C99支持VLA后，数组的长度可以推迟到运行时知道。</p> <h2 id="_2-26-关于指针的类型定义"><a href="#_2-26-关于指针的类型定义" class="header-anchor">#</a> 2.26 关于指针的类型定义</h2> <p>C 语言里，与变量名最近的符号，表明了这个变量的类型，然后一层层向外增加额外的解释。</p> <p>如</p> <p><code>int (*p[10])()</code> 是一个函数指针数组，类型是 <code>int (*[])()</code>。</p> <p><code>int (* (*(*pfunc)(int *)) [5])(int *);</code></p> <p>分析：</p> <p><code>*(*pfunc)(int *)</code>是一个函数指针，参数 <code>int*</code>，返回值是 q 的指针，</p> <p>分析 <code>int (*q[5])(int *)</code> 的指针，得知 q 是一个函数指针数组，</p> <p>所以 pfunc 是一个函数指针，接收参数 <code>int*</code>，返回值是 一个函数指针数组的指针，数组的函数指针的类型
是 参数 ：<code>int *</code>， 返回值 int。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>pfunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等同于下面的写法：</span>

<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// f 是函数指针</span>
<span class="token keyword">typedef</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// g 是数组指针，数组类型是 f</span>
<span class="token keyword">typedef</span> <span class="token function">g</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// h 是函数指针，返回值是数组指针</span>

<span class="token comment">// 强制类型转换，将 0 强制转换为一个函数指针。</span>
<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_2-27-目录结构"><a href="#_2-27-目录结构" class="header-anchor">#</a> 2.27 目录结构</h2> <ul><li><code>src</code> 项目源代码和编译它的 Makefile 文件。
<ul><li>Makefile</li></ul></li> <li><code>incl</code> 存放头文件。</li> <li><code>bin</code> 存放可执行程序。</li> <li><code>lib</code> 存放库文件。</li> <li><code>etc</code> 存放配置文件。</li> <li><code>static</code> 静态库源文件和编译它的 Makefile文件。
<ul><li>Makefile</li></ul></li> <li><code>dynamic</code> 动态库源文件和编译它的 Makefile 文件。
<ul><li>Makefile</li></ul></li> <li><code>docs</code> 项目文档。</li> <li><code>obj</code> 存放目标文件和 Makefile 文件。
<ul><li>Makefile</li></ul></li> <li>Makefile</li></ul> <h2 id="_2-28-static-inline"><a href="#_2-28-static-inline" class="header-anchor">#</a> 2.28 static inline</h2> <p>inline 是基于实现的关键字。</p> <p>inline是c99的特性。在c99中，inline是向编译器建议，将被inline修饰的函数以内联的方式嵌入到调用这个函数的地方。而编译器会判断这样做是否合适，以此最终决定是否这么做。</p> <p>开发者决定不了一个函数是否被内联，开发者只有建议权，只有编译器具有决定权。</p> <p>多数情况下，inline 前面会加static关键字。why?</p> <p>分开理解：</p> <p>static 意味着本地化，每个包含头文件的C文件均在本地产生一个独立的内联函数。当有多个C文件包含头文件时，不会因为函数名相同而报重定义错误。(代价就是代码所占的空间会变大)</p> <p>inline意味着建议内联，至于能否真正内联，看编译器。</p> <p>因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。</p> <p>因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。</p> <p>声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。</p> <p>C++ 中，定义在类中的成员函数默认都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。</p> <p>以下情况不宜使用内联：
（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如&quot;偷偷地&quot;执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</p> <h2 id="_2-29-枚举和宏的区别"><a href="#_2-29-枚举和宏的区别" class="header-anchor">#</a> 2.29 枚举和宏的区别</h2> <p>宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。</p> <p>我们可以将枚举理解为编译阶段的宏。</p> <p>枚举用于定义一组具有名称的整数常量。</p> <p>宏只是单纯的替换。</p> <p>const 是个类型限定符，用于声明一个只读变量，提供类型安全。</p> <h2 id="_2-30-c-语言存储类"><a href="#_2-30-c-语言存储类" class="header-anchor">#</a> 2.30 C 语言存储类</h2> <p>C 语言提供了几种存储类型，用于描述变量在内存中的存储方式和生命周期。以下是 C 语言中常见的存储类型：</p> <p>自动存储类（auto）：这是默认的存储类，用于描述在函数内部声明的局部变量。自动变量的生命周期与其所在的函数调用周期相对应。它们在函数调用时被创建，在函数返回时被销毁。</p> <p>静态存储类（static）：静态存储类用于描述具有静态生命周期的变量。静态变量在程序运行期间一直存在，不受函数调用的影响。静态变量在声明时被初始化，并且只在首次进入声明它的作用域时进行初始化。</p> <p>寄存器存储类（register）：寄存器存储类用于请求编译器将变量存储在寄存器中，以便快速访问。这只是一种建议，编译器可以忽略它。使用寄存器存储类的变量不能获取其地址，因为它们可能没有分配内存。</p> <p>外部存储类（extern）：外部存储类用于描述全局变量或跨文件共享的变量。它们在整个程序的执行期间都存在，并可以被其他文件访问。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>静态线程存储类（thread_local）：静态线程存储类用于描述线程本地存储的变量。每个线程都拥有其自己的变量实例，并且在线程生命周期内保持状态，线程开始时分配，线程结束时销毁。</p> <p>这些存储类可以与变量声明一起使用，以指定变量的存储类型和生命周期。具体使用哪种存储类取决于变量的需求和上下文。</p> <p>C++ 中还有 <code>mutable</code> 存储类，仅适用于类成员变量。以mutable修饰的成员变量可以在const成员函数中修改。</p> <p>_Thread_local 关键词只对声明于命名空间作用域的对象、声明于块作用域的对象及静态数据成员允许。它指示对象拥有线程存储期。它能与 static 或 extern 结合，以分别指定内部或外部链接（除了静态数据成员始终拥有外部链接），但附加的 static 不影响存储期。</p> <p>线程存储期: 对象的存储在线程开始时分配，而在线程结束时解分配。每个线程拥有其自身的对象实例。唯有声明为 thread_local 的对象拥有此存储期。 thread_local 能与 static 或 extern 一同出现，以调整链接。</p> <p><code>static thread_local</code> 和 <code>thread_local</code> 声明是等价的，都是指定变量的周期是在线程内部，并且是静态的。</p> <h2 id="_2-31-标准预定义宏"><a href="#_2-31-标准预定义宏" class="header-anchor">#</a> 2.31 标准预定义宏</h2> <p>编译器支持 ISO C99、C11、C17 和 ISO C++17 标准指定的以下预定义宏：</p> <ul><li><code>__cplusplus</code>：当翻译单元编译为 C++ 时，定义为整数文本值。 其他情况下则不定义。</li> <li><code>__DATE__</code>：当前源文件的编译日期。 日期是 Mmm dd yyyy 格式的恒定长度字符串文本 。 月份名 Mmm 与 C 运行时库 (CRT) asctime 函数生成的缩写月份名相同 。 如果值小于 10，则日期 dd 的第一个字符为空格 。 任何情况下都会定义此宏。</li> <li><code>__FILE__</code>：当前源文件的名称。 <code>__FILE__</code> 展开为字符型字符串文本。 要确保显示文件的完整路径，请使用 /FC（诊断中源代码文件的完整路径）。 任何情况下都会定义此宏。</li> <li><code>__LINE__</code>：定义为当前源文件中的整数行号。 可使用 #line 指令来更改 <code>__LINE__</code> 宏的值。 <code>__LINE__</code> 值的整型类型因上下文而异。 任何情况下都会定义此宏。</li> <li><code>__STDC__</code>：仅在编译为 C，并且指定了 /Za 编译器选项时，定义为 1。 从 Visual Studio 2022 17.2 版本开始，当编译为 C 并指定 /std:c11 或 /std:c17 编译器选项时，它也定义为 1。 其他情况下则不定义。</li> <li><code>__STDC_HOSTED__</code>：如果实现是托管实现并且支持整个必需的标准库，则定义为 1 。 其他情况下则定义为 0。</li> <li><code>__STDC_NO_ATOMICS__</code> 如果实现不支持可选的标准原子，则定义为 1。 当编译为 C 且指定 /std C11 或 C17 选项之一时，MSVC 实现会将其定义为 1。</li> <li><code>__STDC_NO_COMPLEX__</code> 如果实现不支持可选的标准复数，则定义为 1。 当编译为 C 且指定 /std C11 或 C17 选项之一时，MSVC 实现会将其定义为 1。</li> <li><code>__STDC_NO_THREADS__</code> 如果实现不支持可选的标准线程，则定义为 1。 当编译为 C 且指定 /std C11 或 C17 选项之一时，MSVC 实现会将其定义为 1。</li> <li><code>__STDC_NO_VLA__</code> 如果实现不支持可选的可变长度数组，则定义为 1。 当编译为 C 且指定 /std C11 或 C17 选项之一时，MSVC 实现会将其定义为 1。</li> <li><code>__STDC_VERSION__</code> 当编译为 C 且指定 /std C11 或 C17 选项之一时定义。 对于 /std:c11，它扩展到 201112L；对于 /std:c17，则扩展到 201710L。</li> <li><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code> 当指定 /std:c17 或更高版本时，此宏会扩展为 size_t 字面量，该字面量的对齐值由对非对齐感知的 operator new 的调用所保证。 较大的对齐值传递到对齐感知重载，例如 operator new(std::size_t, std::align_val_t)。 有关详细信息，请参阅 /Zc:alignedNew（C++17 过度对齐的分配）。</li> <li><code>__STDCPP_THREADS__</code>：当且仅当程序可以有多个执行线程并编译为 C++ 时，定义为 1。 其他情况下则不定义。</li> <li><code>__TIME__</code>：预处理翻译单元的翻译时间。 时间是 hh:mm:ss 格式的字符型字符串文本，与 CRT asctime 函数返回的时间相同 。 任何情况下都会定义此宏。</li> <li><code>__STDC_ANALYZABLE__</code> 限制某些未定义行为潜在执行结果，提升程序的静态语法分析结果。</li></ul> <h2 id="函数名和函数地址"><a href="#函数名和函数地址" class="header-anchor">#</a> 函数名和函数地址</h2> <p>函数名可以当函数地址用，但是函数名并不是函数的地址，类型不同。</p> <h2 id="const"><a href="#const" class="header-anchor">#</a> const</h2> <p>c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放，不能通过取地址修改。</p> <p>而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放，可以通过指针修改。</p> <p>C 中，一个 const 变量总是需要一块内存空间，const 全局变量默认为外部链接。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/c/c-style.html" class="prev">
        1 简易 C 语言编程规范
      </a></span> <span class="next"><a href="/wiki/c/ccollections.html">
        3 c 问题集
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.8bcba5cc.js" defer></script><script src="/wiki/assets/js/2.4b7299de.js" defer></script><script src="/wiki/assets/js/33.97a174a8.js" defer></script><script src="/wiki/assets/js/3.3ed400f8.js" defer></script>
  </body>
</html>
