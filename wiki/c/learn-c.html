<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2 C 语言拾遗 | CS Wiki</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="shachi 的 CS 知识库">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.40ef89a5.css" as="style"><link rel="preload" href="/wiki/assets/js/app.973721c2.js" as="script"><link rel="preload" href="/wiki/assets/js/2.4b7299de.js" as="script"><link rel="preload" href="/wiki/assets/js/20.c15022d4.js" as="script"><link rel="preload" href="/wiki/assets/js/3.4b540cc1.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.34587702.js"><link rel="prefetch" href="/wiki/assets/js/11.369a09bc.js"><link rel="prefetch" href="/wiki/assets/js/12.df09c36a.js"><link rel="prefetch" href="/wiki/assets/js/13.76a934c4.js"><link rel="prefetch" href="/wiki/assets/js/14.5260fca4.js"><link rel="prefetch" href="/wiki/assets/js/15.15fa35dc.js"><link rel="prefetch" href="/wiki/assets/js/16.ee01f82a.js"><link rel="prefetch" href="/wiki/assets/js/17.3ea6495f.js"><link rel="prefetch" href="/wiki/assets/js/18.f9a974ee.js"><link rel="prefetch" href="/wiki/assets/js/19.e0b5c150.js"><link rel="prefetch" href="/wiki/assets/js/21.493624ec.js"><link rel="prefetch" href="/wiki/assets/js/22.1bf23f2a.js"><link rel="prefetch" href="/wiki/assets/js/23.b32320c6.js"><link rel="prefetch" href="/wiki/assets/js/24.8cf2a7f0.js"><link rel="prefetch" href="/wiki/assets/js/25.02ae29b5.js"><link rel="prefetch" href="/wiki/assets/js/26.6fc30cf4.js"><link rel="prefetch" href="/wiki/assets/js/27.feb65e4b.js"><link rel="prefetch" href="/wiki/assets/js/28.fc08aa0e.js"><link rel="prefetch" href="/wiki/assets/js/4.2e33d51d.js"><link rel="prefetch" href="/wiki/assets/js/5.5b3fd24d.js"><link rel="prefetch" href="/wiki/assets/js/6.3b848e60.js"><link rel="prefetch" href="/wiki/assets/js/7.2b4da95a.js"><link rel="prefetch" href="/wiki/assets/js/8.0e6132d7.js"><link rel="prefetch" href="/wiki/assets/js/9.f2499e42.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.40ef89a5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><img src="/wiki/favicon.ico" alt="CS Wiki" class="logo"> <span class="site-name can-hide">CS Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link router-link-active">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  数据库
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  python
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/c/.html#" class="nav-link">
  x86汇编
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link router-link-active">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  数据库
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/c/.html#" class="nav-link">
  python
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/c/.html#" class="nav-link">
  x86汇编
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/wiki/c/" aria-current="page" class="sidebar-link">C Program Language</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>inbox</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/c/c-style.html" class="sidebar-link">1 简易 C 语言编程规范</a></li><li><a href="/wiki/c/learn-c.html" aria-current="page" class="active sidebar-link">2 C 语言拾遗</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-1-c-语言版本" class="sidebar-link">2.1 C 语言版本</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-2-编译过程" class="sidebar-link">2.2 编译过程</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-3-宏" class="sidebar-link">2.3 宏</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-4-字符串" class="sidebar-link">2.4 字符串</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-5-内存映像" class="sidebar-link">2.5 内存映像</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-6-二进制文件和文本文件" class="sidebar-link">2.6 二进制文件和文本文件</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-7-浮点数的存储" class="sidebar-link">2.7 浮点数的存储</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-8-位域" class="sidebar-link">2.8 位域</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-9-断言" class="sidebar-link">2.9 断言</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-10-变参函数" class="sidebar-link">2.10 变参函数</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-11-内存对齐" class="sidebar-link">2.11 内存对齐</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-12-联合体" class="sidebar-link">2.12 联合体</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-13-register-存储类型" class="sidebar-link">2.13 register 存储类型</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-14-数组指针" class="sidebar-link">2.14 数组指针</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-15-数组名和指针的区别" class="sidebar-link">2.15 数组名和指针的区别</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-16-字节序" class="sidebar-link">2.16 字节序</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-17-位运算取余" class="sidebar-link">2.17  位运算取余</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-18-补码的运算" class="sidebar-link">2.18 补码的运算</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-19-整型提升" class="sidebar-link">2.19 整型提升</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-20-bool-类型" class="sidebar-link">2.20 _Bool 类型</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-21-占位符" class="sidebar-link">2.21 占位符</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-22-输出格式控制" class="sidebar-link">2.22 输出格式控制</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-23-size-t" class="sidebar-link">2.23 size_t</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-24-零长度数组" class="sidebar-link">2.24 零长度数组</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-25-vlc-变长数组" class="sidebar-link">2.25 VLC 变长数组</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-26-关于指针的类型定义" class="sidebar-link">2.26 关于指针的类型定义</a></li><li class="sidebar-sub-header"><a href="/wiki/c/learn-c.html#_2-27-目录结构" class="sidebar-link">2.27 目录结构</a></li></ul></li><li><a href="/wiki/c/ccollections.html" class="sidebar-link">3 c 问题集</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/c/kandrc/" class="sidebar-heading clickable"><span>K&amp;R C</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/c/glibc/" class="sidebar-heading clickable"><span>glibc 学习</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_2-1-c-语言版本"><a href="#_2-1-c-语言版本" class="header-anchor">#</a> 2.1 C 语言版本 <span class="badge warning" style="vertical-align:top;" data-v-ee04238a>TODO</span></h2> <p>TODO: 标准介绍，各标准特性</p> <h3 id="_2-1-1-c-99"><a href="#_2-1-1-c-99" class="header-anchor">#</a> 2.1.1 C 99</h3> <ul><li>增加了对编译器的限制，比如源始码每行要求至少支持到 4095 字节，变量名函数名的要求支持到 63 字节（extern 要求支持到 31）。</li> <li>增强了预处理功能。例如：
<ul><li>巨集支持取可变参数 <code>#define Macro(...) __VA_ARGS__</code></li> <li>使用巨集的时候，允许省略参数，被省略的参数会被扩展成空串。</li> <li>支持//开头的单行注释（这个特性实际上在C89的很多编译器上已经被支持了）</li></ul></li> <li>增加了新关键字 <code>restrict</code>, <code>inline</code>, <code>_Complex</code>, <code>_Imaginary</code>, <code>_Bool</code> <ul><li>支持 <code>long long</code>, <code>long double _Complex</code>, <code>float _Complex</code> 等类型</li></ul></li> <li>支持不定长的数组，即数组长度可以在运行时决定，比如利用变量作为数组长度。声明时使用 <code>int a[var]</code> 的形式。不过考虑到效率和实现，不定长数组不能用在全局，或 struct 与 union 。</li> <li>变量声明不必放在语句块的开头，for语句提倡写成for(int i=0;i&lt;100;++i) 的形式，即i只在for语句块内部有效。</li> <li>允许采用 <code>type-name{xx,xx,xx}</code>这样类似C++的构造函数的形式构造匿名的结构体，即复合文字特性。如 <code>(int[]){1,3}</code>,<code>(int){1}</code>，复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。</li> <li>初始化结构体的时候允许对特定的元素赋值，形式为：
<ul><li><code>struct test{int a[3]，b;} foo[] = { [0].a = {1}, [1].a = 2 };</code></li> <li><code>struct test{int a, b, c, d;} foo = { .a = 1, .c = 3, 4, .b = 5 }; // 3,4 是对 .c,.d 赋值的</code></li></ul></li> <li>格式化字符串中，利用 <code>\u</code> 支持 unicode 的字符。</li> <li>支持 16 进制的浮点数的描述。</li> <li>printf, scanf 的格式化串增加了对 long long int 类型的支持。</li> <li>浮点数的内部数据描述支持了新标准，可以使用 #pragma 编译器指令指定。</li> <li>除了已有的 <code>__LINE__</code>和<code>__FILE__</code> 以外，增加了<code>__func__</code>得到当前的函数名。</li> <li>允许编译器化简非常数的表达式。</li> <li>修改了<code>/</code>和<code>%</code>处理负数时的定义，这样可以给出明确的结果，例如在C89中-22 / 7 = -3, -22 % 7 = -1，也可以-22 / 7= -4, -22 % 7 = 6。 而C99中明确为 -22 / 7 = -3, -22 % 7 = -1，只有一种结果。</li> <li>取消了函数返回类型默认为 int 的规定。</li> <li>允许在 struct 的最后定义的数组不指定其长度，写做 <code>[]</code>(flexible array member)柔性数组。</li> <li>const const int i 将被当作 const int i 处理。</li> <li>增加和修改了一些标准头文件，比如定义 bool 的 <code>&lt;stdbool.h&gt;</code> ，定义一些标准长度的int的 <code>&lt;inttypes.h&gt;</code>，定义复数的<code>&lt;complex.h&gt;</code>，定义宽字符的<code>&lt;wctype.h&gt;</code>，类似于泛型的数学函数<code>&lt;tgmath.h&gt;</code>，浮点数相关的<code>&lt;fenv.h&gt;</code>。在<code>&lt;stdarg.h&gt;</code>增加了va_copy用于复制...的参数。<code>&lt;time.h&gt;</code>里增加了struct tmx，对struct tm做了扩展。</li> <li>输入输出对宽字符以及长整数等做了相应的支持。</li></ul> <h2 id="_2-2-编译过程"><a href="#_2-2-编译过程" class="header-anchor">#</a> 2.2 编译过程</h2> <p><code>gcc x.c</code> 默认的产物是 <code>a.out</code>，assembler output 的缩写。</p> <h3 id="_2-2-1-预处理"><a href="#_2-2-1-预处理" class="header-anchor">#</a> 2.2.1 预处理</h3> <p>调用预处理器<code>cpp</code>，完成宏展开、头文件包含、处理条件编译、删除注释等工作。</p> <p>一些预定义的宏：</p> <p><code>__DATE__</code> 进行预处理的日期（“Mmm dd yyyy”形式的字符串文字，如May 27 2006）</p> <p><code>__FILE__</code> 代表当前源代码文件名的字符串文字 ，包含了详细路径，如 <code>G:/program/study/c+/test1.c</code></p> <p><code>__LINE__</code> 代表当前源代码中的行号的整数常量</p> <p><code>__TIME__</code> 源文件编译时间，格式微“hh：mm：ss”，如：09:11:10；</p> <p><code>__FUNCTION__</code> 当前所在函数名</p> <p><code>gcc -E -o a.i a.c</code></p> <h3 id="_2-2-2-编译"><a href="#_2-2-2-编译" class="header-anchor">#</a> 2.2.2 编译</h3> <p>调用编译器 <code>cc1</code>，把源程序翻译成目标系统的汇编文件 <code>.s</code>。</p> <p>将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，加工为当前机器支持的汇编代码。</p> <p><code>gcc -S -o a.s a.i</code></p> <h3 id="_2-2-3-汇编"><a href="#_2-2-3-汇编" class="header-anchor">#</a> 2.2.3 汇编</h3> <p>调用汇编器 <code>as</code>，将汇编指令翻译成机器指令，生成可重定位目标文件。</p> <p><code>gcc -c -o a.o a.s</code></p> <h3 id="_2-2-4-链接"><a href="#_2-2-4-链接" class="header-anchor">#</a> 2.2.4 链接</h3> <p>调用链接器 <code>ld</code> ，将生成的可重定位文件与相关库文件链接，生成可执行目标文件。</p> <ol><li>符号分析</li> <li>重定位。（重新分配地址）</li></ol> <p><code>gcc -o a a.o</code></p> <h2 id="_2-3-宏"><a href="#_2-3-宏" class="header-anchor">#</a> 2.3 宏 <span class="badge warning" style="vertical-align:top;" data-v-ee04238a>TODO</span></h2> <p>避免使用宏，尽量使用编译器而不用预处理。</p> <p>多行的宏，需要用下面的结构包围起来：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">do</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>TODO: c99 的变参宏</p> <h2 id="_2-4-字符串"><a href="#_2-4-字符串" class="header-anchor">#</a> 2.4 字符串</h2> <p>不要将字符串常量用于非 <code>const</code> 的字符串变量。</p> <p>字符串常量是 <code>const char*</code> 类型。</p> <p>字符数组可以看作 <code>char* const</code> 类型，数组名执行地址不可变，但可以通过指针修改字符串。</p> <h2 id="_2-5-内存映像"><a href="#_2-5-内存映像" class="header-anchor">#</a> 2.5 内存映像</h2> <p>CPU是计算机的核心，决定了计算机的数据处理能力和寻址能力。CPU一个时钟，也就是一次能处理的数据的大小由寄存器的位数和数据总线的宽度决定，通常所说的CPU的32位、64位可以理解为寄存器的位数，也可以理解为数据总线的宽度。</p> <p>​以32位CPU为例子，即一次能处理32Bit，即4个字节的数据。典型的32位处理器是Intel 80386,它的数据总线宽度有32位，地址总线宽度也是32位，寻址能力为2<sup>32</sup> = 4GB</p> <p>数据总线用于在CPU和内存之间传输数据，地址总线用于在内存上定位数据，地址总线的宽度往往随着数据总线的宽度增大而增大，以访问更大的内存。</p> <p>​同时CPU支持的物理内存只是理论上的数据，实际应用中会受到操作系统的限制，比如说win7 64位家庭版最大支支持8GB和16GB的物理内存，win7 64位专业版可以支持到192GB的物理内存。但是32位CPU寻址能力没有这么大，所以要通过两次寻址来实现。</p> <p>所谓的虚拟空间，就是程序可以使用的虚拟地址的有效范围。虚拟地址和物理地址的映射关系由操作系统决定，相应地，虚拟地址空间的大小也由操作系统决定，但还会受到编译模式的影响。</p> <p>windows和Linux都会对虚拟地址进行了限制，仅使用虚拟地址的低48位（6个字节），总的虚拟空间大小位为2<sup>48</sup>=256TB，而且任何虚拟地址的48位至63位必须与47位一致。</p> <p>​如果内存大于物理内存，或者内存中剩余的空间不够容纳当前的程序，那么操作系统会将内存中用不到的一部分数据写入磁盘，等需要的时候再读取回来。程序只管使用4GB的内存，而不用关心硬件资源。</p> <p>32位内存映像如下：</p> <p><img src="/c/%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F.png" alt=""></p> <p><code>ulimit -s</code> 查看栈空间大小，单位 <code>Mb</code>。</p> <p>c语言四大内存分区</p> <ul><li>栈区（stack）:存放函数形参和局部变量（auto类型），由编译器自动分配和释放（<code>.stack</code>）</li> <li>堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由OS回收。（<code>.heap</code>）</li> <li>全局/静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块（<code>.bss</code>，<code>.data</code>），编译时就分配好了。</li> <li>常量区：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。（<code>.rodata</code>)程序代码区：存放程序的二进制代码，内存由系统管理（<code>.text</code>）</li></ul> <p>其中rodata区和text区在加载时会合并到一个段中，该段称为常量区，该区域的内容只允许读，不允许修改。</p> <p>data区和bss区在加载时合并到一个段中，该段被称为全局区。</p> <p>在64位环境下，虚拟地址空间大小为 256TB，Linux 将高 128TB 的空间分配给内核使用，而将低 128TB 的空间分配给用户程序使用。</p> <p>64位内存空间分布情况如下：</p> <p><img src="/c/64%E4%BD%8D%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt=""></p> <p>注意：</p> <p>栈增长方向是：高地址向低地址。</p> <p>堆增长方向是：低地址向高地址。</p> <p>这个上下文里说的“栈”是函数调用栈，是以“栈帧”（stack frame）为单位的。每一次函数调用会在栈上分配一个新的栈帧，在这次函数调用结束时释放其空间。</p> <p>被调用函数（callee）的栈帧相对调用函数（caller）的栈帧的位置反映了栈的增长方向：如果被调用函数的栈帧比调用函数的在更低的地址，那么栈就是向下增长；反之则是向上增长。而在一个栈帧内，</p> <p>局部变量是如何分布到栈帧里的（所谓栈帧布局，stack frame layout），这完全是编译器的自由。</p> <p>至于数组元素与栈的增长方向：C与C++语言规范都规定了数组元素是分布在连续递增的地址上的。</p> <p>每个函数都是一个栈帧，栈的分配是按着这个来的，而栈帧里是怎么分配完全看编译器来。</p> <p><img src="/c/%E6%A0%88%E5%A2%9E%E9%95%BF.png" alt=""></p> <p>内核空间（1G，0xc0000000 ~ 0xffffffff)</p> <p>用户空间（3G, 0x00000000 ~ 0xC0000000)</p> <p>当进程/线程运行在内核空间时就处于内核态，而进程/线程运行在用户空间时则处于用户态。</p> <h2 id="_2-6-二进制文件和文本文件"><a href="#_2-6-二进制文件和文本文件" class="header-anchor">#</a> 2.6 二进制文件和文本文件</h2> <p>数据在物理上的存储方式是二进制的，即由0/1字符串构成。而我们解读这些的方式有两种：基于字符编码，和基于值编码。</p> <h3 id="_2-6-1-基于字符编码"><a href="#_2-6-1-基于字符编码" class="header-anchor">#</a> 2.6.1 基于字符编码</h3> <p>即每个我们肉眼可读的字符都有唯一对应的0/1字符串，我们读、写这些字符都使用同一套编码方式。</p> <p>如果某文件的数据使用基于字符的编码，那么该文件即为“文本文件”。</p> <p>文本文件则在二进制的基础上，进行了字符编码，因此，我们看到的诸如 .txt 以及程序文件都是字符形式。</p> <p>常见的基于字符的编码有：ASCII码，Unicode编码。</p> <h3 id="_2-6-2-基于值编码"><a href="#_2-6-2-基于值编码" class="header-anchor">#</a> 2.6.2 基于值编码</h3> <p>可以理解为自定义的编码。</p> <p>如果某文件的数据使用基于值的编码，那么该文件即为“二进制文件”。不同的应用程序对二进制文件中的每个值会有不同的解读，就像不同的编码对文本文件中的每一/多个字节有不同的解读。</p> <p>常见的二进制文件有可执行程序、图形、图像、声音等等。</p> <h2 id="_2-7-浮点数的存储"><a href="#_2-7-浮点数的存储" class="header-anchor">#</a> 2.7 浮点数的存储</h2> <p>32位下的浮点数存储：</p> <p>符号位 1 + 指数位（8）+小数位（24）</p> <p>IEEE754规定, 指数位用于表示[-127, 128]范围内的指数</p> <p>规定: 在32位单精度类型中, 这个偏移量是127. 在64位双精度类型中, 偏移量是1023. 所以, 这里的偏移量是127。</p> <p>有了偏移量, 指数位中始终都是一个非负整数。</p> <h2 id="_2-8-位域"><a href="#_2-8-位域" class="header-anchor">#</a> 2.8 位域</h2> <p>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。</p> <p>在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">bs</span><span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> m<span class="token punctuation">;</span>
    <span class="token class-name">uint32_t</span> n <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> ch <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>都定义为 <code>unsigned</code> 类型。</p> <p>位域技术就是在成员变量所占用的内存中选出一部分位宽来存储数据。</p> <p>C99规定int、unsigned int和 _Bool 可以作为位域类型，但编译器几乎都对此作了扩展。</p> <ol><li>如果一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</li></ol> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">bs</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> a<span class="token operator">:</span><span class="token number">4</span>
    <span class="token keyword">unsigned</span> <span class="token operator">:</span><span class="token number">0</span> <span class="token comment">/*空域*/</span>
    <span class="token keyword">unsigned</span> b<span class="token operator">:</span><span class="token number">4</span> <span class="token comment">/*从下一单元开始存放*/</span>
    <span class="token keyword">unsigned</span> c<span class="token operator">:</span><span class="token number">4</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>空域用 0 填充单元剩下的空间。</p> <ol start="2"><li>位域的长度不能大于数据类型本身的长度，比如int类型就能超过32位二进位。</li> <li>位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。</li></ol> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">k</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token operator">:</span><span class="token number">1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">:</span><span class="token number">2</span> <span class="token comment">/*该2位不能使用*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> b<span class="token operator">:</span><span class="token number">3</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> c<span class="token operator">:</span><span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用位域的主要目的是压缩存储，其大致规则为：</p> <ol><li><p>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止</p></li> <li><p>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</p></li> <li><p>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，tdm-gcc，GCC采取压缩方式；</p></li> <li><p>如果位域字段之间穿插着非位域字段，则不进行压缩；</p></li> <li><p>整个结构体的总大小为最宽基本类型成员大小的整数倍。</p></li></ol> <h2 id="_2-9-断言"><a href="#_2-9-断言" class="header-anchor">#</a> 2.9 断言</h2> <p><code>assert</code>宏的原型定义在<code>assert.h</code>中，其作用是如果它的条件返回错误，则终止程序执行。</p> <p><code>assert</code>的作用是现计算表达式 <code>expression</code> ，如果其值为假（即为0），那么它先向 <code>stderr</code> 打印一条出错信息,然后通过调用 <code>abort</code> 来终止程序运行。</p> <p>通过 <code>NDEBUG</code> 宏关闭，在调试结束后，可以通过在包含 <code>#include</code> 的语句之前插入 <code>#define NDEBUG</code> 来禁用 <code>assert</code> 调用。</p> <p><code>gcc -DNDEBUG</code></p> <p><code>assert</code> 的缺点是，频繁调用会极大的影响程序的性能，增加额外的开销。</p> <h2 id="_2-10-变参函数"><a href="#_2-10-变参函数" class="header-anchor">#</a> 2.10 变参函数 <span class="badge warning" style="vertical-align:top;" data-v-ee04238a>TODO</span></h2> <p>TODO: 补充</p> <h2 id="_2-11-内存对齐"><a href="#_2-11-内存对齐" class="header-anchor">#</a> 2.11 内存对齐</h2> <p>(1) 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p> <p>(2) 平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p> <p>(3) 空间原因：没有进行内存对齐的结构体或类会浪费一定的空间，当创建对象越多时，消耗的空间越多。</p> <p>如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p> <p>在设置结构体或类时，不考虑内存对齐问题，会浪费一些空间。</p> <p>对齐规则：</p> <ol><li>struct内部每个成员按自身大小对齐，起始地址是自身宽度的整数倍。</li> <li>struct末尾紧贴着一个相同类型的struct，也能够使下一个struct内成员对齐。</li> <li>填充的值为垃圾值，非空。</li></ol> <p>永远不要用 <code>pragma pack</code>。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>push<span class="token punctuation">)</span> </span><span class="token comment">// 保存当前的对齐方式</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    <span class="token keyword">short</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_2-12-联合体"><a href="#_2-12-联合体" class="header-anchor">#</a> 2.12 联合体</h2> <p>联合体大小是以所占空间最大的为标准分配空间。</p> <h2 id="_2-13-register-存储类型"><a href="#_2-13-register-存储类型" class="header-anchor">#</a> 2.13 register 存储类型</h2> <p>直接存在 CPU 的寄存器中。</p> <h2 id="_2-14-数组指针"><a href="#_2-14-数组指针" class="header-anchor">#</a> 2.14 数组指针</h2> <p>对二维数组的定义，第一维的长度是可以缺省的，但是第二维不可缺省。</p> <p>对数组取地址，指针类型就是数组指针。</p> <p><code>int arr[][4] = {0};</code></p> <p><code>int (*p)[4] = arr</code></p> <h2 id="_2-15-数组名和指针的区别"><a href="#_2-15-数组名和指针的区别" class="header-anchor">#</a> 2.15 数组名和指针的区别</h2> <p>数组名的含义：</p> <ol><li>数组在内存空间的名称。</li> <li>数组的起始地址。</li></ol> <p>区别一：</p> <ol><li>对数组名取地址得到的是数组所指元素的地址。</li> <li>对指针取地址得到的是指针变量自身的地址。</li></ol> <p>区别二：</p> <ol><li>数组名是常量指针。</li> <li>指针是变量指针。</li></ol> <p>区别三：</p> <ol><li><code>sizfof(数组名)</code> 得到的整个数组的字节数。</li> <li><code>sizeof(指针)</code> 得到的是指针类型的字节数。</li></ol> <p>指针的访问效率远远高于数组名的访问效率。</p> <p>对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关。</p> <h2 id="_2-16-字节序"><a href="#_2-16-字节序" class="header-anchor">#</a> 2.16 字节序</h2> <p>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。</p> <p>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p> <p>字节序是由 CPU 决定的。</p> <p>对于多字节的数据，在内存中存储时，存放字节的顺序为字节序。</p> <p>大端序</p> <p>高位放在低地址，低位放在高地址。</p> <p>小端序。</p> <p>高位放在高地址，地位放在低地址。</p> <p>判断字节序：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

   <span class="token keyword">union</span><span class="token punctuation">{</span>
       <span class="token class-name">int32_t</span> n<span class="token punctuation">;</span>
       <span class="token class-name">int8_t</span> ch<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>data<span class="token punctuation">;</span>

    data<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">0x00000001</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>ch <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;小端序\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;大端序\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_2-17-位运算取余"><a href="#_2-17-位运算取余" class="header-anchor">#</a> 2.17  位运算取余</h2> <p>位运算适用于除数是 2<sup>n</sup></p> <p>的情况。对 2<sup>n</sup></p> <p>取余，就预示着数字向右移 n 位，这右移的 n 位就是余数。</p> <h2 id="_2-18-补码的运算"><a href="#_2-18-补码的运算" class="header-anchor">#</a> 2.18 补码的运算</h2> <p>补码减法运算的公式： <code>[ x －y ] 补＝ [ x ] 补－ [ y ] 补＝ [ x ] 补＋ [ －y ] 补</code></p> <h2 id="_2-19-整型提升"><a href="#_2-19-整型提升" class="header-anchor">#</a> 2.19 整型提升</h2> <p>在 <code>K&amp;R</code> 和 <code>C89</code> 的早期实现中，基于 <code>short</code> 和 <code>char</code> 的算术运算陷入两难的困境，因为可能会产生两种不同的结果。因此，在C99中很明确地定义了整型提升的规则. 如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被转成 <code>unsigned int</code> 型。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。</p> <p>表达式中的字符型和短整型操作数在使用之前被转换为普通类型，这种转换称为整形提升。</p> <p><code>char</code> 和 <code>short</code> 在参与运算时，均是先转换为 <code>int</code> 再进行。</p> <p>通常情况下，在对int类型的数值作运算时，CPU的运算速度是最快的。在x86上，32位算术运算的速度比16位算术运算的速度快一倍。C语言是一个注重效率的语言，所以它会作整型提升，使得程序的运行速度尽可能地快。</p> <h2 id="_2-20-bool-类型"><a href="#_2-20-bool-类型" class="header-anchor">#</a> 2.20 _Bool 类型</h2> <p>C99 中，提供了 <code>_Bool</code> 类型，<code>_Bool</code> 只能赋值为 0 或 1，非 0 的值都会被存储为 1。</p> <h2 id="_2-21-占位符"><a href="#_2-21-占位符" class="header-anchor">#</a> 2.21 占位符</h2> <ul><li><code>%c</code>：字符。</li> <li><code>%d</code>：十进制整数。</li> <li><code>%e</code>：使用科学计数法的浮点数，指数部分的e为小写。</li> <li><code>%E</code>：使用科学计数法的浮点数，指数部分的E为大写。</li> <li><code>%i</code>：整数，可读取非十进制整数。</li> <li><code>%f</code>：小数（包含float类型和double类型）。</li> <li><code>%g</code>：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的e为小写。</li> <li><code>%G</code>：等同于%g，唯一的区别是指数部分的E为大写。</li> <li><code>%hd</code>：十进制 short int 类型。</li> <li><code>%ho</code>：八进制 short int 类型。</li> <li><code>%hx</code>：十六进制 short int 类型。</li> <li><code>%hu</code>：unsigned short int 类型。</li> <li><code>%ld</code>：十进制 long int 类型。</li> <li><code>%lo</code>：八进制 long int 类型。</li> <li><code>%lx</code>：十六进制 long int 类型。</li> <li><code>%lu</code>：unsigned long int 类型。</li> <li><code>%lld</code>：十进制 long long int 类型。</li> <li><code>%llo</code>：八进制 long long int 类型。</li> <li><code>%llx</code>：十六进制 long long int 类型。</li> <li><code>%llu</code>：unsigned long long int 类型。</li> <li><code>%Le</code>：科学计数法表示的 long double 类型浮点数。</li> <li><code>%Lf</code>：long double 类型浮点数。</li> <li><code>%lf</code>: double</li> <li><code>%n</code>：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。</li> <li><code>%o</code>：八进制整数。</li> <li><code>%p</code>：指针。</li> <li><code>%s</code>：字符串。</li> <li><code>%u</code>：无符号整数（unsigned int）。</li> <li><code>%x</code>：十六进制整数。</li> <li><code>%zu</code>：<code>size_t</code>类型。</li> <li><code>%zd</code>: <code>ssize_t</code> 类型。</li> <li><code>%%</code>：输出一个百分号。</li> <li><code>%lc</code>：打印宽字符。</li> <li><code>%ls</code>：打印宽字符串。</li></ul> <p><code>%c</code> 和 <code>%hhd</code> 区别：二者针对类型都是单字节整数，也就是<code>char</code>或者<code>unsigned char</code>。不过<code>%c</code>在输入输出的时候，是按照字符操作的。<code>%hhd</code>是按照整数操作。</p> <h2 id="_2-22-输出格式控制"><a href="#_2-22-输出格式控制" class="header-anchor">#</a> 2.22 输出格式控制</h2> <ul><li><code>-</code>：字段宽度内左对齐。</li> <li><code>+</code>：显示正负号。</li> <li><code>#</code>：输出进制前缀。</li> <li><code>0</code>：填充0，指定宽度内。</li> <li><code>[num]</code>：指定宽度，超过不截断，少的用空格填充。</li> <li><code>*</code>：待指定宽度，第一个参数为宽度。</li> <li><code>.[num]</code>：精度，不够用 0 填充（写入数字最小位数，对于 <code>e</code>、<code>f</code>，指定小数位数。对于 <code>s</code>，指定输出最大字符数。</li> <li><code>.*</code>：待指定精度，第一个参数为精度。</li></ul> <h2 id="_2-23-size-t"><a href="#_2-23-size-t" class="header-anchor">#</a> 2.23 size_t</h2> <p><code>sizeof</code> 操作符的返回结果类型是 <code>size_t</code>，在程序设计的时候，如果处理 <code>size_t</code> ，占位符需要为 <code>%zu</code>，如果是 <code>ssize_t</code> ，则需要用 <code>%zd</code>。</p> <p><code>size_t</code> 表示 C 中任何对象所能达到的最大长度。</p> <p>在声明注入字符数或者数组索引这样的长度变量时用 <code>size_t</code> 是最好的做法，它经常用于循环计数器、数组索引。</p> <p>如：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">99</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>使用 <code>size_t</code> 需包含头文件 <code>&lt;stddef.h&gt;</code></p> <h2 id="_2-24-零长度数组"><a href="#_2-24-零长度数组" class="header-anchor">#</a> 2.24 零长度数组 <span class="badge warning" style="vertical-align:top;" data-v-ee04238a>TODO</span></h2> <h2 id="_2-25-vlc-变长数组"><a href="#_2-25-vlc-变长数组" class="header-anchor">#</a> 2.25 VLC 变长数组</h2> <p>尽量不要使用 VLA，可通过：<code>gcc -Wvla</code> 检测，C++ 不支持。</p> <p>变长数组的实现默认是通过动态设置栈顶来实现的。</p> <p>变长数组允许不在栈上，有些编译器可能用 <code>malloc</code> 实现。</p> <p>VLA目前在MSVC/GCC上的实现全部都是利用到了alloca() ，在栈上动态申请一块内存（移动栈指针），当函数返回时，栈指针回归外一层函数时的状态，因而alloca() 分配的内存得以释放。</p> <p>实际工程中不推荐使用VLA。原因如下：若数组长度很大，有造成爆栈的危险。OS给进程的栈的大小是有限的。</p> <p>使用alloca()后会造成部分与栈操作有关的编译器优化失效。因此，若数组长度有可能很大，请直接在堆上分配避免爆栈。</p> <p>vla 不支持初始化。</p> <h2 id="_2-26-关于指针的类型定义"><a href="#_2-26-关于指针的类型定义" class="header-anchor">#</a> 2.26 关于指针的类型定义</h2> <p>C 语言里，与变量名最近的符号，表明了这个变量的类型，然后一层层向外增加额外的解释。</p> <p>如</p> <p><code>int (*p[10])()</code> 是一个函数指针数组，类型是 <code>int (*[])()</code></p> <h2 id="_2-27-目录结构"><a href="#_2-27-目录结构" class="header-anchor">#</a> 2.27 目录结构</h2> <ul><li><code>src</code> 项目源代码和编译它的 Makefile 文件。
<ul><li>Makefile</li></ul></li> <li><code>incl</code> 存放头文件。</li> <li><code>bin</code> 存放可执行程序。</li> <li><code>lib</code> 存放库文件。</li> <li><code>etc</code> 存放配置文件。</li> <li><code>static</code> 静态库源文件和编译它的 Makefile文件。
<ul><li>Makefile</li></ul></li> <li><code>dynamic</code> 动态库源文件和编译它的 Makefile 文件。
<ul><li>Makefile</li></ul></li> <li><code>docs</code> 项目文档。</li> <li><code>obj</code> 存放目标文件和 Makefile 文件。
<ul><li>Makefile</li></ul></li> <li>Makefile</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/c/c-style.html" class="prev">
        1 简易 C 语言编程规范
      </a></span> <span class="next"><a href="/wiki/c/ccollections.html">
        3 c 问题集
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.973721c2.js" defer></script><script src="/wiki/assets/js/2.4b7299de.js" defer></script><script src="/wiki/assets/js/20.c15022d4.js" defer></script><script src="/wiki/assets/js/3.4b540cc1.js" defer></script>
  </body>
</html>
