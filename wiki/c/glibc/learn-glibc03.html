<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>glibc 学习（三）线程 | CS Wiki</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="shachi 的 CS 知识库">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.40ef89a5.css" as="style"><link rel="preload" href="/wiki/assets/js/app.6005c093.js" as="script"><link rel="preload" href="/wiki/assets/js/2.4b7299de.js" as="script"><link rel="preload" href="/wiki/assets/js/23.014c43a0.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.023c6faa.js"><link rel="prefetch" href="/wiki/assets/js/11.f71b8eb3.js"><link rel="prefetch" href="/wiki/assets/js/12.0e6853b3.js"><link rel="prefetch" href="/wiki/assets/js/13.e0d914e3.js"><link rel="prefetch" href="/wiki/assets/js/14.8bdf7c13.js"><link rel="prefetch" href="/wiki/assets/js/15.9e0345c7.js"><link rel="prefetch" href="/wiki/assets/js/16.a1d1e6c3.js"><link rel="prefetch" href="/wiki/assets/js/17.58c9759b.js"><link rel="prefetch" href="/wiki/assets/js/18.a135b98c.js"><link rel="prefetch" href="/wiki/assets/js/19.b404a248.js"><link rel="prefetch" href="/wiki/assets/js/20.dcb264c7.js"><link rel="prefetch" href="/wiki/assets/js/21.938790b5.js"><link rel="prefetch" href="/wiki/assets/js/22.2613edb8.js"><link rel="prefetch" href="/wiki/assets/js/24.b38bddd1.js"><link rel="prefetch" href="/wiki/assets/js/25.5db6c161.js"><link rel="prefetch" href="/wiki/assets/js/26.a0e63e72.js"><link rel="prefetch" href="/wiki/assets/js/27.c3efab24.js"><link rel="prefetch" href="/wiki/assets/js/28.f71e96f2.js"><link rel="prefetch" href="/wiki/assets/js/29.7f5d8683.js"><link rel="prefetch" href="/wiki/assets/js/3.6d633953.js"><link rel="prefetch" href="/wiki/assets/js/30.31775b12.js"><link rel="prefetch" href="/wiki/assets/js/31.9103ea9d.js"><link rel="prefetch" href="/wiki/assets/js/32.edd6a0fb.js"><link rel="prefetch" href="/wiki/assets/js/33.33c23cb6.js"><link rel="prefetch" href="/wiki/assets/js/34.fa89b974.js"><link rel="prefetch" href="/wiki/assets/js/35.578c57c3.js"><link rel="prefetch" href="/wiki/assets/js/36.61a4611a.js"><link rel="prefetch" href="/wiki/assets/js/37.35f00b52.js"><link rel="prefetch" href="/wiki/assets/js/38.56c36766.js"><link rel="prefetch" href="/wiki/assets/js/39.ed160d8b.js"><link rel="prefetch" href="/wiki/assets/js/4.2e33d51d.js"><link rel="prefetch" href="/wiki/assets/js/40.dd849684.js"><link rel="prefetch" href="/wiki/assets/js/41.0a126ce9.js"><link rel="prefetch" href="/wiki/assets/js/42.f055cc8b.js"><link rel="prefetch" href="/wiki/assets/js/43.ce48b1bc.js"><link rel="prefetch" href="/wiki/assets/js/44.500b5a4d.js"><link rel="prefetch" href="/wiki/assets/js/45.73aaa5c9.js"><link rel="prefetch" href="/wiki/assets/js/46.5ec1f340.js"><link rel="prefetch" href="/wiki/assets/js/47.1bd50fbc.js"><link rel="prefetch" href="/wiki/assets/js/48.39997210.js"><link rel="prefetch" href="/wiki/assets/js/49.3336d241.js"><link rel="prefetch" href="/wiki/assets/js/5.5b3fd24d.js"><link rel="prefetch" href="/wiki/assets/js/50.e2bfaa49.js"><link rel="prefetch" href="/wiki/assets/js/51.f2603124.js"><link rel="prefetch" href="/wiki/assets/js/52.521181ca.js"><link rel="prefetch" href="/wiki/assets/js/53.96ed2bb8.js"><link rel="prefetch" href="/wiki/assets/js/54.0e345e97.js"><link rel="prefetch" href="/wiki/assets/js/55.8af9a828.js"><link rel="prefetch" href="/wiki/assets/js/56.e97b21d9.js"><link rel="prefetch" href="/wiki/assets/js/57.64b3d1c4.js"><link rel="prefetch" href="/wiki/assets/js/58.2c7d3f71.js"><link rel="prefetch" href="/wiki/assets/js/59.6cbe62a0.js"><link rel="prefetch" href="/wiki/assets/js/6.3b848e60.js"><link rel="prefetch" href="/wiki/assets/js/60.7eda6d97.js"><link rel="prefetch" href="/wiki/assets/js/61.78598666.js"><link rel="prefetch" href="/wiki/assets/js/62.dc469974.js"><link rel="prefetch" href="/wiki/assets/js/63.7ca244a4.js"><link rel="prefetch" href="/wiki/assets/js/64.d4c4d0d6.js"><link rel="prefetch" href="/wiki/assets/js/65.5a26ec0e.js"><link rel="prefetch" href="/wiki/assets/js/7.c67aa8fa.js"><link rel="prefetch" href="/wiki/assets/js/8.431ae0d7.js"><link rel="prefetch" href="/wiki/assets/js/9.d2107a17.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.40ef89a5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><img src="/wiki/favicon.ico" alt="CS Wiki" class="logo"> <span class="site-name can-hide">CS Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link router-link-active">
  C
</a></div><div class="nav-item"><a href="/wiki/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/shell.html" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/gdb.html" class="nav-link">
  gdb
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/CMake.html" class="nav-link">
  CMake
</a></li><li class="dropdown-subitem"><a href="https://github.com/chunni98/learn-python-with-lxf" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Python3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/collections.html" class="nav-link">
  问题集
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/learn-arm.html" class="nav-link">
  ARM 体系结构
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/driver/" class="nav-link">
  Linux 内核驱动
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link router-link-active">
  C
</a></div><div class="nav-item"><a href="/wiki/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/shell.html" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/gdb.html" class="nav-link">
  gdb
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/CMake.html" class="nav-link">
  CMake
</a></li><li class="dropdown-subitem"><a href="https://github.com/chunni98/learn-python-with-lxf" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Python3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/collections.html" class="nav-link">
  问题集
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/learn-arm.html" class="nav-link">
  ARM 体系结构
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/driver/" class="nav-link">
  Linux 内核驱动
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/wiki/c/" aria-current="page" class="sidebar-link">C Program Language</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>inbox</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/c/c-style.html" class="sidebar-link">1 简易 C 语言编程规范</a></li><li><a href="/wiki/c/learn-c.html" class="sidebar-link">2 C 语言拾遗</a></li><li><a href="/wiki/c/ccollections.html" class="sidebar-link">3 c 问题集</a></li><li><a href="/wiki/c/json-c.html" class="sidebar-link">4 json-c 库使用</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/c/kandrc/" class="sidebar-heading clickable"><span>K&amp;R C</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/c/glibc/" class="sidebar-heading clickable router-link-active open"><span>glibc 学习</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/c/glibc/learn-glibc01.html" class="sidebar-link">glibc 学习（一）I/O</a></li><li><a href="/wiki/c/glibc/learn-glibc02.html" class="sidebar-link">glibc 学习（二）时间</a></li><li><a href="/wiki/c/glibc/learn-glibc03.html" aria-current="page" class="active sidebar-link">glibc 学习（三）线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/c/glibc/learn-glibc03.html#_3-1-线程函数" class="sidebar-link">3.1 线程函数</a></li><li class="sidebar-sub-header"><a href="/wiki/c/glibc/learn-glibc03.html#_3-2-互斥锁函数" class="sidebar-link">3.2 互斥锁函数</a></li><li class="sidebar-sub-header"><a href="/wiki/c/glibc/learn-glibc03.html#_3-3-条件变量函数" class="sidebar-link">3.3 条件变量函数</a></li><li class="sidebar-sub-header"><a href="/wiki/c/glibc/learn-glibc03.html#_3-4-线程特定存储函数" class="sidebar-link">3.4 线程特定存储函数</a></li><li class="sidebar-sub-header"><a href="/wiki/c/glibc/learn-glibc03.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/wiki/c/glibc/learn-glibc04.html" class="sidebar-link">glibc 学习（四）原子操作</a></li><li><a href="/wiki/c/glibc/learn-glibc05.html" class="sidebar-link">glibc 学习（五）数学库</a></li><li><a href="/wiki/c/glibc/learn-glibc06.html" class="sidebar-link">glibc 学习（六）stdlib</a></li><li><a href="/wiki/c/glibc/learn-glibc07.html" class="sidebar-link">glibc 学习（七）字符串处理</a></li><li><a href="/wiki/c/glibc/learn-glibctemp.html" class="sidebar-link">glibc 学习</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>threads.h是C11标准新增的多线程支持库，在此之前C语言实现多线程，除了使用系统API外用的最多的
就是pthread.h了，threads.h在语法上和pthread.h非常相似。</p> <p>C语言包括对线程、原子操作、互斥、条件变量和线程专用存储的内置支持。</p> <p>若编译器定义宏常量 <code>__STDC_NO_THREADS__</code>(C11) ，则不提供头文件<code>&lt;threads.h&gt;</code> 和所有列于此的名称。</p> <p>退出和错误码以及互斥锁类型定义：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code> <span class="token comment">/* Exit and error codes.  */</span>
 <span class="token keyword">enum</span>
  <span class="token punctuation">{</span>
    thrd_success  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    thrd_busy     <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    thrd_error    <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
    thrd_nomem    <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    thrd_timedout <span class="token operator">=</span> <span class="token number">4</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/* Mutex types.  */</span>
  <span class="token keyword">enum</span>
  <span class="token punctuation">{</span>
    mtx_plain     <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    mtx_recursive <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    mtx_timed     <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_3-1-线程函数"><a href="#_3-1-线程函数" class="header-anchor">#</a> 3.1 线程函数</h2> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">thrd_start_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个新的执行 __func 函数的线程，__func 的参数通过 __arg 传递，</span>
<span class="token comment">// 如果成功，thr 将设置为新线程的标识符。</span>
<span class="token comment">// 创建成功返回 thrd_success，否则返回其他。</span>
<span class="token keyword">int</span> <span class="token function">thrd_create</span> <span class="token punctuation">(</span><span class="token class-name">thrd_t</span> <span class="token operator">*</span>__thr<span class="token punctuation">,</span> <span class="token class-name">thrd_start_t</span> __func<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>__arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 返回当前的线程标识符  */</span>
<span class="token class-name">thrd_t</span> <span class="token function">thrd_current</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 清除当前线程，清除任何线程本地数据并且释放资源。
   向__res 中返回指定的值。  */</span>
<span class="token comment">// thrd_exit 会将线程置于已分离状态，线程资源会在其退出后被自动释放，而不需要主线程显式等待和回收资源。</span>
<span class="token keyword">void</span> <span class="token function">thrd_exit</span> <span class="token punctuation">(</span><span class="token keyword">int</span> __res<span class="token punctuation">)</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__noreturn__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 从当前环境中分离通过 __thr 标志的的线程。（不允许父线程清理。）*/</span>
<span class="token comment">// 由操作系统负责回收线程的资源。</span>
<span class="token keyword">int</span> <span class="token function">thrd_detach</span> <span class="token punctuation">(</span><span class="token class-name">thrd_t</span> __thr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 阻塞当前线程，直到线程 __thr 执行完成，
   如果__res 是非空的，将会存储 __thr 在退出时的返回值。
   如果某一线程内没有调用 thrd_detach 函数将自己设置为detach状态，
   那么当它结束时必须由另外一个线程调用thrd_join函数将它留下的僵死状态变为结束，
   并回收它所占用的系统资源。*/</span>
<span class="token keyword">int</span> <span class="token function">thrd_join</span> <span class="token punctuation">(</span><span class="token class-name">thrd_t</span> __thr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>__res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 检查 __lhs 和 __rhs 是否指向同一个线程。
   因为不同编译器实现的方式可能不一样，可能 thrd_t 是结构体。  */</span>
<span class="token keyword">int</span> <span class="token function">thrd_equal</span> <span class="token punctuation">(</span><span class="token class-name">thrd_t</span> __lhs<span class="token punctuation">,</span> <span class="token class-name">thrd_t</span> __rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">/* 至少在持续时间指向的基于timespec的持续时间过去之前阻止当前线程的执行。
   如果收到未忽略的信号，睡眠可能会提前恢复。
   在这种情况下，如果 remaining 不是 NULL，则剩余持续时间将存储到剩余指向的对象中。*/</span>
<span class="token keyword">int</span> <span class="token function">thrd_sleep</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>__time_point<span class="token punctuation">,</span>
                <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>__remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 停止当前线程并调用调度器来决定接下来执行哪一个线程。
    当前线程也可能被调度器选中继续执行。*/</span>
<span class="token keyword">void</span> <span class="token function">thrd_yield</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h2 id="_3-2-互斥锁函数"><a href="#_3-2-互斥锁函数" class="header-anchor">#</a> 3.2 互斥锁函数</h2> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/* 新建一个新的互斥对象，并指定类型为 __type. 如果成功，__mutex 指定新的互斥对象  */</span>
<span class="token comment">// mtx_plain –简单的，非递归互斥对象</span>
<span class="token comment">// mtx_timed –非递归的，支持超时的互斥对象</span>
<span class="token comment">// mtx_plain | mtx_recursive –简单的，递归互斥对象</span>
<span class="token comment">// mtx_timed | mtx_recursive –支持超时的递归互斥对象</span>
<span class="token keyword">int</span> <span class="token function">mtx_init</span> <span class="token punctuation">(</span><span class="token class-name">mtx_t</span> <span class="token operator">*</span>__mutex<span class="token punctuation">,</span> <span class="token keyword">int</span> __type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 阻塞当前线程直到 __mutex 指向的互斥对象解锁。*/</span>
<span class="token keyword">int</span> <span class="token function">mtx_lock</span> <span class="token punctuation">(</span><span class="token class-name">mtx_t</span> <span class="token operator">*</span>__mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 阻塞当前线程直到互斥锁解锁，
   或者计数时间到.  */</span>
<span class="token keyword">int</span> <span class="token function">mtx_timedlock</span> <span class="token punctuation">(</span><span class="token class-name">mtx_t</span> <span class="token operator">*</span>__restrict __mutex<span class="token punctuation">,</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>__restrict __time_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 在不阻塞的情况下试图锁定互斥对象.
    如果互斥对象是空闲的，则会控制该互斥对象，否则将会立即返回。 */</span>
<span class="token keyword">int</span> <span class="token function">mtx_trylock</span> <span class="token punctuation">(</span><span class="token class-name">mtx_t</span> <span class="token operator">*</span>__mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 解锁互斥对象，可能会唤醒其他等待此互斥对象的线程。  */</span>
<span class="token keyword">int</span> <span class="token function">mtx_unlock</span> <span class="token punctuation">(</span><span class="token class-name">mtx_t</span> <span class="token operator">*</span>__mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 摧毁互斥对象  */</span>
<span class="token keyword">void</span> <span class="token function">mtx_destroy</span> <span class="token punctuation">(</span><span class="token class-name">mtx_t</span> <span class="token operator">*</span>__mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="_3-3-条件变量函数"><a href="#_3-3-条件变量函数" class="header-anchor">#</a> 3.3 条件变量函数</h2> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/* I初始化一个新的指向 __cond 的条件变量。  */</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">cnd_init</span> <span class="token punctuation">(</span><span class="token class-name">cnd_t</span> <span class="token operator">*</span>__cond<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 取消阻塞一个当前等待 __cond 指向的条件变量的线程。  */</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">cnd_signal</span> <span class="token punctuation">(</span><span class="token class-name">cnd_t</span> <span class="token operator">*</span>__cond<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 取消阻塞所有当前等待 __cond 指向的条件变量的线程。  */</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">cnd_broadcast</span> <span class="token punctuation">(</span><span class="token class-name">cnd_t</span> <span class="token operator">*</span>__cond<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 自动对mtx互斥对象进行解锁操作，然后阻塞，直到条件变量cond被cnd_signal或cnd_broadcast
调用唤醒，当前线程变为非阻塞时，它将在返回之前锁住mtx互斥对象 */</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">cnd_wait</span> <span class="token punctuation">(</span><span class="token class-name">cnd_t</span> <span class="token operator">*</span>__cond<span class="token punctuation">,</span> <span class="token class-name">mtx_t</span> <span class="token operator">*</span>__mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 与cnd_wait类似，例外之处是当前线程在xt时间点上还未能被唤醒时，
它将返回，此时返回值为thrd_timeout。cnd_wait和cnd_timedwait函数在被调用前，
当前线程必须锁住mtx互斥对象。 */</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">cnd_timedwait</span> <span class="token punctuation">(</span><span class="token class-name">cnd_t</span> <span class="token operator">*</span>__restrict __cond<span class="token punctuation">,</span>
            <span class="token class-name">mtx_t</span> <span class="token operator">*</span>__restrict __mutex<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>__restrict __time_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
            co
<span class="token comment">/* 摧毁互斥变量  */</span>
<span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">cnd_destroy</span> <span class="token punctuation">(</span><span class="token class-name">cnd_t</span> <span class="token operator">*</span>__COND<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="_3-4-线程特定存储函数"><a href="#_3-4-线程特定存储函数" class="header-anchor">#</a> 3.4 线程特定存储函数</h2> <p>线程专有数据(TSD) 和线程局部数据 (TLS)</p> <p>在多线程程序中，经常要用全局变量来实现多个函数间的数据共享。由于数据空间是共享的，因此全局变量也为
所有线程共有。但有时应用程序设计中必要提供线程私有的全局变量，这个变量仅在线程中有效，但却可以跨过
多个函数访问，比如 linux 下 errno 的实现。</p> <p>比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用
同名而不同变量地址的线程相关数据结构。这样的数据结构可以由 Posix 线程库维护，成为线程私有数据
(Thread-specific Data，或称为 TSD)。</p> <p>如果需要在一个线程内部的各个函数调用（全局）都能访问、但其它线程不能访问的变量
（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现。这就是TLS。</p> <p>C 语言支持两种方式使用 TLS：<code>_Thread_local</code> 和 <code>tss_create()</code>，一个是语言层面支持，一个是库层面支持。</p> <p>在多线程开发中，并不是所有的同步都需要加锁的，有时巧妙的数据分解也可减少锁的碰撞。
每个线程都拥有自己私有数据，使用它可以减少线程间共享数据之间的同步开销。</p> <p>如果要将一些遗留代码进行线程化，很多函数都使用了全局变量，而在多线程环下，最好的方法可能是将这些
全局量变量换成线程私有的全局变量即可。</p> <p>TSD和TLS就是专门用来处理线程私有数据的。 它的生存周期是整个线程的生存周期，但它在每个线程都有
一份拷贝，每个线程只能read-write-update属于自己的那份。如果通过指针方式来
read-write-update其它线程的备份，它的行为是未定义的。</p> <p>C11提供了TLS方法，可以像一般变量的方式去访问线程私有变量。
做法很简单，在声明和定义线程私变量时指定 <code>_Thread_local</code> 存储修饰符即可。</p> <p>C 语言为不同的存储类别定义了多个关键字，例如 auto，static，register，extern。</p> <p>从 C11 标准的规范开始，添加了 <code>_Thread_local</code> 指定符。<code>_Thread_local</code> 存储持续时间始于
线程创建时，并终止于线程终止。启动线程时，将初始化存储在 <code>_Thread_local</code> 对象中的值，
并在线程终止时对其进行清理。通常，线程局部对象是避免共享资源中竞争条件的另一种选择。
也就是说，我们隐式地将线程之间的数据分开，因为 <code>_Thread_local</code> 修饰的对象在每个线程具有单独的实例。</p> <p>C11 <code>threads.h</code> 中定义了 <code>thread_local</code> 宏，以表示 <code>_Thread_local</code>。</p> <p>C11 有如下的描述：</p> <ol><li>在声明式中，_Thread_local只能单独使用，或者跟static或extern一起使用。</li> <li>在某一区快中声明某一对象，如果声明存储修饰符有_Thread_local，那么必须同时有static或extern。</li> <li>如果_Thread_local出现在一对象的某个声明式中，那么此对象的其余各处声明式都应该有_Thread_local存储修饰符。</li> <li>如果某一对象的声明式中出现_Thread_local存储修饰符，那么它有线程储存期。该对象的生命周期为线程的整个执行周期，它在线程出生时创建，并在线程启动时初始化。每个线程均有一份该对象，使用声明时的名字即可引用正在执行当前表达式的线程所关联的那个对象。</li></ol> <p>TLS方式与传统的全局变量或static变量的使用方式完全一致，不同的是，TLS变量在不同的线程上均有各自的一份。
线程访问TLS时不会产生data race，因为不需要任何加锁机制。TLS方式需要编译器的支持，对于任何
_Thread_local变量，编译器要将之编译并生成放到各个线程的private memory区域，并且访问这些变量
时，都要获得当前线程的信息，从而访问正确的物理对象，当然这一切都是在链接过程早已安排好的。</p> <p>线程存储为每个线程指定一个地址空间并且自动维护它，这个空间可以是静态区域的内存也可以是堆上的内存，
显然选择堆作为动态临时空间比较理想，因为每次可以分配不同的大小且用完后可以释放。首先需要为自动管理
的内存空间创建一个类型为tss_t的密匙，然后调用tss_create()方法将密匙关联到一个析构函数，当线程
执行完毕后会自动调用这个析构函数。</p> <p>密匙的优点是不同线程的存储空间可以共用一个密匙，tss_t对象会分别引用它们。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/* 调用函数 __func 只一次，即使是被多个线程调用也是这样。
   必须使用相同的 __flag 对象进行所有调用。  */</span>

<span class="token comment">// 可用于在一个多线程同时执行的环境下来初始化一个变量，即著名的延迟初始化单例模式。</span>
<span class="token comment">// call_once函数使用flag来保确func只被调用一次。第一个线程使用flag去调用call_once时，</span>
<span class="token comment">// 函数func会被调用，而接下来的使用相同flag来调用的call_once，func均不会再次被调用，</span>
<span class="token comment">// 以保正func在多线程环境只被调用一次。</span>
<span class="token keyword">void</span> <span class="token function">call_once</span> <span class="token punctuation">(</span>once_flag <span class="token operator">*</span>__flag<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>__func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建新的特定于线程的存储密钥，并将其存储在 tss_key 指向的对象中。尽管相同的键值可由不同的线程</span>
<span class="token comment">// 使用，但 tss_set 绑定到键的值是在每个线程的基础上维护的，并且在调用线程的生命周期内一直存在。</span>
<span class="token comment">// 值 NULL 与所有现有线程中的新创建的密钥相关联，并且在线程创建后，与所有TSS密钥相关联的值都初始化为 NULL 。</span>
<span class="token comment">// 如果 destructor 不是空指针，则还将关联析构函数，该析构函数在 thrd_exit （但不是 tss_delete 且不在程序通过 exit 终止）释放存储时被调用。</span>
<span class="token comment">// 在特定于线程的存储析构函数中对 tss_create 的调用导致未定义的行为。</span>
<span class="token comment">// 只要线程终止时与key关联的值不为NULL，则 destructor 所指的函数将会自动被调用。</span>
<span class="token comment">// 如果一个线程中有多个线程局部存储变量，那么对各个变量所对应的destructor函数的调用顺序是</span>
<span class="token comment">// 不确定的，因此，每个变量的destructor函数的设计应该相互独立。</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">tss_create</span> <span class="token punctuation">(</span><span class="token class-name">tss_t</span> <span class="token operator">*</span>__tss_id<span class="token punctuation">,</span> <span class="token class-name">tss_dtor_t</span> __destructor<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 只能在线程函数中调用。</span>
<span class="token comment">// 返回由tss_key标识的当前线程的线程专有存储中保存的值。 不同的线程可能会获得由同一个密钥标识的不同值。</span>
<span class="token comment">//在线程启动时（请参阅thrd_create），与所有TSS键相关的值为NULL。 使用tss_set可以将不同的值放入线程专有存储中。</span>
<span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">tss_get</span> <span class="token punctuation">(</span><span class="token class-name">tss_t</span> __tss_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 只能在线程函数中调用。</span>
<span class="token comment">// 将当前线程的tss_id标识的线程专有存储的值设置为val。 不同的线程可以为同一个键设置不同的值。</span>
<span class="token comment">// 析构函数如果可用，则不会被调用。</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">tss_set</span> <span class="token punctuation">(</span><span class="token class-name">tss_t</span> __tss_id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>__val<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 销毁 tss_id 标识的特定于线程的存储。</span>
<span class="token comment">//析构函数（如果已由 tss_create 注册）不会被调用（它们只能在线程退出时通过 thrd_exit</span>
<span class="token comment">//或从线程函数返回而调用），程序员有责任确保每个知道的线程在调用 tss_delete 之前， tss_id 执行了所有必要的清理。</span>
<span class="token comment">//如果 tss_delete 而另一个线程执行析构函数被调用 tss_id ，它是不确定这是否改变调用的到相关的析构函数的数量。</span>
<span class="token comment">//如果在调用线程正在执行析构函数的同时调用 tss_delete ，则与 tss_id 相关联的析构函数将不会在此线程上再次执行。</span>
<span class="token comment">// delete()并不检查当前是否有线程正在使用该线程局部数据变量，也不会调用清理函数destructor，</span>
<span class="token comment">// 只是将其释放以供下一次调用pthread_key_create()使用。</span>
<span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">tss_delete</span> <span class="token punctuation">(</span><span class="token class-name">tss_t</span> __tss_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li><a href="https://www.ibadboy.net/archives/2323.html" target="_blank" rel="noopener noreferrer">C11新增多线程支持库-threads.h参考手册<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="#">/usr/include/threads.h</a></li> <li><a href="https://runebook.dev/zh/docs/c/thread" target="_blank" rel="noopener noreferrer">C<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/wangquan1992/article/details/108344721" target="_blank" rel="noopener noreferrer">linux多线程：tls的实现方式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/c/glibc/learn-glibc02.html" class="prev">
        glibc 学习（二）时间
      </a></span> <span class="next"><a href="/wiki/c/glibc/learn-glibc04.html">
        glibc 学习（四）原子操作
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.6005c093.js" defer></script><script src="/wiki/assets/js/2.4b7299de.js" defer></script><script src="/wiki/assets/js/23.014c43a0.js" defer></script>
  </body>
</html>
