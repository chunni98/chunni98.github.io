<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>问题集 | CS Wiki</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="shachi 的 CS 知识库">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.cf734400.css" as="style"><link rel="preload" href="/wiki/assets/js/app.a9cbc012.js" as="script"><link rel="preload" href="/wiki/assets/js/2.4b7299de.js" as="script"><link rel="preload" href="/wiki/assets/js/30.710f9039.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.023c6faa.js"><link rel="prefetch" href="/wiki/assets/js/11.7b506b9b.js"><link rel="prefetch" href="/wiki/assets/js/12.a18f7714.js"><link rel="prefetch" href="/wiki/assets/js/13.5355cffb.js"><link rel="prefetch" href="/wiki/assets/js/14.9a8f8fbb.js"><link rel="prefetch" href="/wiki/assets/js/15.b6b239d3.js"><link rel="prefetch" href="/wiki/assets/js/16.5cdec6d2.js"><link rel="prefetch" href="/wiki/assets/js/17.58c9759b.js"><link rel="prefetch" href="/wiki/assets/js/18.be401e1c.js"><link rel="prefetch" href="/wiki/assets/js/19.6f274486.js"><link rel="prefetch" href="/wiki/assets/js/20.a7a052f3.js"><link rel="prefetch" href="/wiki/assets/js/21.d3737ebb.js"><link rel="prefetch" href="/wiki/assets/js/22.0234a233.js"><link rel="prefetch" href="/wiki/assets/js/23.a887dc83.js"><link rel="prefetch" href="/wiki/assets/js/24.b72aebf9.js"><link rel="prefetch" href="/wiki/assets/js/25.bf72279a.js"><link rel="prefetch" href="/wiki/assets/js/26.48a912b9.js"><link rel="prefetch" href="/wiki/assets/js/27.d5457a55.js"><link rel="prefetch" href="/wiki/assets/js/28.2bd842a0.js"><link rel="prefetch" href="/wiki/assets/js/29.e9d02bfe.js"><link rel="prefetch" href="/wiki/assets/js/3.347cffd3.js"><link rel="prefetch" href="/wiki/assets/js/31.6ddefe52.js"><link rel="prefetch" href="/wiki/assets/js/32.647383cd.js"><link rel="prefetch" href="/wiki/assets/js/33.6b5bbc55.js"><link rel="prefetch" href="/wiki/assets/js/34.cc3c8896.js"><link rel="prefetch" href="/wiki/assets/js/35.ed09c55f.js"><link rel="prefetch" href="/wiki/assets/js/36.a076c949.js"><link rel="prefetch" href="/wiki/assets/js/37.22e9ddb1.js"><link rel="prefetch" href="/wiki/assets/js/38.dc95d115.js"><link rel="prefetch" href="/wiki/assets/js/39.d795a7ba.js"><link rel="prefetch" href="/wiki/assets/js/4.e3173cf0.js"><link rel="prefetch" href="/wiki/assets/js/40.199dc79b.js"><link rel="prefetch" href="/wiki/assets/js/41.0d9b8a87.js"><link rel="prefetch" href="/wiki/assets/js/42.7f0c852a.js"><link rel="prefetch" href="/wiki/assets/js/43.69a0a51c.js"><link rel="prefetch" href="/wiki/assets/js/44.892f6327.js"><link rel="prefetch" href="/wiki/assets/js/45.ce6f0ee1.js"><link rel="prefetch" href="/wiki/assets/js/46.dcc656cd.js"><link rel="prefetch" href="/wiki/assets/js/5.5b3fd24d.js"><link rel="prefetch" href="/wiki/assets/js/6.3b848e60.js"><link rel="prefetch" href="/wiki/assets/js/7.1d469969.js"><link rel="prefetch" href="/wiki/assets/js/8.18290f0f.js"><link rel="prefetch" href="/wiki/assets/js/9.2bb47d5a.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.cf734400.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><img src="/wiki/favicon.ico" alt="CS Wiki" class="logo"> <span class="site-name can-hide">CS Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  python
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/gdb.html" class="nav-link">
  gdb
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/emebedded/.html#" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/collections.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  问题集
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/emebedded/.html#" class="nav-link">
  python
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/gdb.html" class="nav-link">
  gdb
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/emebedded/.html#" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/collections.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  问题集
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-mcu-mpu-cpu-soc-有什么区别"><a href="#_1-mcu-mpu-cpu-soc-有什么区别" class="header-anchor">#</a> 1 MCU/MPU/CPU/SoC 有什么区别？</h2> <h3 id="_1-1-mcu"><a href="#_1-1-mcu" class="header-anchor">#</a> 1.1 MCU</h3> <p>MCU(MicroControllerUnit)中文名称为微控制单元，又称单片微型计算机，
是指随着大规模集成电路的出现及其发展，将计算机的CPU、RAM、ROM、定时数器和多种I/O接口集成在
一片芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制。
MCU通常被用来控制简单的设备，如家用电器、车辆控制、传感器、嵌入式系统等。</p> <h3 id="_1-2-mpu"><a href="#_1-2-mpu" class="header-anchor">#</a> 1.2 MPU</h3> <p>即微处理器单元，通常代表功能强大的CPU，可理解为 增强型CPU ，但不是为任何已有的特定计算目的而设计的芯片。
这种芯片往往是计算机和高端系统的核心。MCU集成了片上外围器件而 MPU 没有集成片上外围器件。
例如嵌入式开发者最熟悉的 ARM 的 Cortex-A 芯片，他们都属于 MPU。</p> <h3 id="_1-3-cpu"><a href="#_1-3-cpu" class="header-anchor">#</a> 1.3 CPU</h3> <p>中央处理器，简称 CPU（Central Processing Unit），中央处理器主要包括两个部分，
即控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。
电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。
中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。
所谓的计算机的可编程性主要是指对CPU的编程。</p> <h3 id="_1-4-soc"><a href="#_1-4-soc" class="header-anchor">#</a> 1.4 SoC</h3> <p>SoC(System on Chip，整体的一个电路系统，完成一个具体功能的东西)：指的是片上系统，
MCU只是芯片级的芯片，而SoC是系统级的芯片，它既MCU那样有内置RAM、ROM
同时又像MPU那样强大，不单单是放简单的代码，可以放系统级的代码，
SOC是一种高度集成的芯片，将多个功能模块（例如处理器、内存、外设等）集成到一个芯片上，
可以用于构建复杂的系统，如智能手机和平板电脑等。
MCU 是简单的 SoC，只能裸机或者运行 RTOS。</p> <p><img src="/stm32/2.png" alt=""></p> <h2 id="_2-vcc-vss-vdd-vee-vbat-有什么区别"><a href="#_2-vcc-vss-vdd-vee-vbat-有什么区别" class="header-anchor">#</a> 2 VCC/VSS/VDD/VEE/VBAT 有什么区别</h2> <h3 id="_2-1-vcc"><a href="#_2-1-vcc" class="header-anchor">#</a> 2.1 VCC</h3> <p>C=circuit，表示电路的意思，即接入电路的电压。</p> <h3 id="_2-2-vdd"><a href="#_2-2-vdd" class="header-anchor">#</a> 2.2 VDD</h3> <p>D=device，表示器件的意思，即器件内部的工作电压。</p> <h3 id="_2-3-vss"><a href="#_2-3-vss" class="header-anchor">#</a> 2.3 VSS</h3> <p>S=series，表示公共连接的意思，通常指电路公共接地端电压。</p> <h3 id="_2-4-vee"><a href="#_2-4-vee" class="header-anchor">#</a> 2.4 VEE</h3> <p>负电压供电;场效应管的源极(S)</p> <h3 id="_2-5-vbat"><a href="#_2-5-vbat" class="header-anchor">#</a> 2.5 VBAT</h3> <p>battery，电池</p> <p>当使用电池或其他电源连接到VBAT脚上时，当VDD 断电时，可以保存备份寄存器的内容和维持RTC的功能。如果应用中没有使用外部电池，VBAT引脚应接到VDD引脚上。</p> <p>一般来说VCC=模拟电源，VDD=数字电源，VSS=数字地，VEE=负电源。</p> <h2 id="_3-什么是上拉电阻和下拉电阻"><a href="#_3-什么是上拉电阻和下拉电阻" class="header-anchor">#</a> 3 什么是上拉电阻和下拉电阻？</h2> <p>上拉电阻和下拉电阻是在数字电路中使用的两种电阻。
它们通常用于控制数字信号的电平。</p> <ul><li>上拉电阻是连接到信号线和正电源之间的电阻，用于将信号线上的电平拉高。</li> <li>下拉电阻是连接到信号线和地之间的电阻，用于将信号线上的电平拉低。</li></ul> <p>在数字电路中，上拉电阻和下拉电阻通常用于控制输入信号的电平状态，
以确保正确的信号传输和处理。</p> <h2 id="_4-晶振是什么"><a href="#_4-晶振是什么" class="header-anchor">#</a> 4 晶振是什么？</h2> <p>晶振是一种用于产生稳定和精确的时钟信号的电子元件。它是由一块晶体和一些电路组成的。当晶体被电场激发时，它会产生一个固定频率的振荡信号，这个振荡信号被用来调节电子设备中各种电路的时序和节拍。晶振通常被用于计算机、通信设备、数字电视、智能手机等各种电子设备中。</p> <h2 id="_5-单片机烧录方式有哪些"><a href="#_5-单片机烧录方式有哪些" class="header-anchor">#</a> 5 单片机烧录方式有哪些？</h2> <h3 id="_5-1-mcu-地址映射"><a href="#_5-1-mcu-地址映射" class="header-anchor">#</a> 5.1 mcu 地址映射</h3> <ul><li>ISP（In-System Programming）在系统编程，使用引导程序（Bootloader）加上外围UART/SPI等接口进行烧录。</li> <li>ICP （In-circuit programmer）在电路编程，使用SWD/JTAG接口。</li> <li>IAP（In-Application Programming）指MCU可以在系统中获取新代码并对自己重新编程，即用程序来改变程序。</li></ul> <p><img src="/stm32/19.png" alt=""></p> <p><strong>Flash(Main memory)主存储区</strong></p> <p>通常编写的代码是放到主存储区的起始位置开始运行（0x08000000），烧录程序时直接将程序烧录到这里即可。</p> <p><strong>System memory 系统存储区</strong></p> <p>起始位置 0x1fff 0000，是 stm32 出厂时，由 ST 在这个区域内部预置了一段 Bootloader，也就是 ISP 程序，这是一块 ROM，出厂后无法修改。</p> <h3 id="_5-2-启动方式选择"><a href="#_5-2-启动方式选择" class="header-anchor">#</a> 5.2 启动方式选择</h3> <p>STM32有两个BOOT引脚，通过配置不同的高低电平，可以让单片机从不同的地址开始运行。</p> <p><strong>BOOT0 = 0，BOOT1 任意</strong></p> <p>从主闪存存储器（0x0800 0000）启动，这种情况，就是直接在这个地址烧录，烧录完直接在这个地址运行。</p> <p>使用 JTAG/SWD 模式下载程序。</p> <p><strong>BOOT0 = 1,BOOT1 = 0</strong></p> <p>从系统存储器启动，这种情况，使用串口方式烧录程序，此时，单片机从系统存储器（0x1fff 0000）启动，
运行的是出场预置的 Bootloader 程序，接受串口发来的程序，并将其写入 main mermory (0x0800 0000)
烧录完成后，将 boot0 拉低，就可以运行烧录的程序了。</p> <p>使用 ISP 串口烧录。</p> <p><strong>BOOT0=1，BOOT1=1</strong></p> <p>这种情况是从内存中启动，内置SRAM（也就是STM32的内存中），既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。</p> <h2 id="_6-volitale-有什么用"><a href="#_6-volitale-有什么用" class="header-anchor">#</a> 6 volitale 有什么用？</h2> <p>避免编译器对变量进行优化。</p> <p>编译器对变量的优化有三个方面：</p> <ol><li>删除多余的语句。</li></ol> <p>例如：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>优化的情况下，编译器会删除前面的两条语句。</p> <ol start="2"><li>可能会重新排列语句的顺序。</li> <li>在多线程编程中，为了提高效率，可能将共享资源在每个线程中都保存一个备份到高速缓存中，造成同一个变量放在了两个高速缓冲区中，而对它们的读写操作就不是同一个内存，导致读写的不是同一个变量。</li></ol> <h2 id="_7-寄存器和内存、cache的区别"><a href="#_7-寄存器和内存、cache的区别" class="header-anchor">#</a> 7 寄存器和内存、cache的区别</h2> <p>寄存器：寄存器是有触发器或锁存器组成，通常由触发器组成，寄存器拥有非常高的读写速度，所以在寄存器之间传递数据非常快</p> <p>CPU 在一次时钟周期能访问一次寄存器。</p> <p>内存：内存就是存储器，由半导体器件构成。</p> <p>计算机的存储层次（memory hierarchy）之中，寄存器（register）最快，内存其次，最慢的是硬盘。</p> <p>寄存器、内存和高速缓存都是计算机中的存储器件，但它们之间有以下区别：</p> <ol><li><p>寄存器：是位于CPU内部的最快速的存储器件，用于存储指令、数据和地址等。由于寄存器与CPU之间的距离非常近，所以访问速度非常快，但是容量非常有限，一般只有几十个字节。</p></li> <li><p>内存：是计算机中存储数据和程序的主要存储器件，容量比寄存器大得多，可以存储大量的数据和程序。内存的读写速度比寄存器慢，但比较快，一般以纳秒为单位。</p></li> <li><p>高速缓存：是一种介于寄存器和内存之间的存储器件，用于加速CPU访问内存的速度。高速缓存的容量比寄存器和内存都要小，但是它的读写速度比内存要快得多，一般以CPU时钟周期为单位。高速缓存通常分为多级，一级高速缓存离CPU最近，速度最快，容量最小，而二级、三级高速缓存离CPU越远，速度越慢，容量越大。</p></li></ol> <p>速度：register &gt; L1 cache &gt; L2 cache &gt; memory &gt; storage</p> <h2 id="_8-总线是什么"><a href="#_8-总线是什么" class="header-anchor">#</a> 8 总线是什么？</h2> <p>总线（bus）是计算机内部传输数据的通道，它是一组并行的电子线路或电气连接，通过这些线路或连接可以在计算机中的各个部件之间传输数据、地址和控制信息。总线在计算机体系结构中扮演着重要的角色，因为它们可以在不同的设备之间提供通信，并且协调计算机内部的所有活动。</p> <p>总线的种类包括<strong>地址总线、数据总线和控制总线</strong>。地址总线用于传输内存地址，数据总线用于传输数据，控制总线用于传输控制信号，如时钟信号、读写信号等。不同类型的总线在计算机中承担不同的任务，并且它们的带宽和时序等方面的特性也会影响到计算机的性能。</p> <h2 id="_9-ahb-apb-是什么"><a href="#_9-ahb-apb-是什么" class="header-anchor">#</a> 9 AHB，APB 是什么？</h2> <p>AHP：高级高性能总线</p> <p>APB指的是“高级外设总线”（Advanced Peripheral Bus），是ARM处理器的外设总线之一。APB总线是一个低速、低功耗的总线，主要用于连接低带宽的外设，如定时器、GPIO（通用输入/输出端口）、UART（通用异步收发器）等。APB总线通常被用作系统中的次要总线，因为它的数据传输速率比主总线（如AHB）慢，但是它可以在处理器和外设之间提供简单、灵活的通信。</p> <p>APB总线和AHB总线一样，都是ARM体系结构中的标准总线，这些总线可以使处理器和外设之间进行快速、可靠的通信。在ARM处理器中，APB总线和AHB总线通常被组合使用，以提供处理器和外设之间的多层次连接，从而实现高效的数据交换和控制。</p> <p>APB和AHB总线，类似于 PC 里的北桥和南桥总线。
南桥总线上挂接的都是鼠标、键盘这些慢速的设备，北桥上挂接显卡等高速设备。南桥频率低，北桥频率高。另外，南桥最后也要接到北桥上。
这些感觉都类似于APB和AHB。</p> <h2 id="_10-icode-dcode-system-dma-总线-总线矩阵是什么"><a href="#_10-icode-dcode-system-dma-总线-总线矩阵是什么" class="header-anchor">#</a> 10 ICode/DCode/System/DMA 总线/总线矩阵是什么？</h2> <h3 id="_10-1-icode"><a href="#_10-1-icode" class="header-anchor">#</a> 10.1 ICode</h3> <p>该总线将CortexTM-M3内核的指令总线与闪存指令接口相连接。指令预取在此总线上完成。</p> <p>ICode 中的I 表示Instruction，即指令。程序编译之后生成的二进制文件都是一条条指令，烧录后存放在FLASH中，内核要读取这些指令来执行程序就必须通过ICode 总线，它几乎每时每刻都需要被使用，它是专门用来取指的。</p> <p>ICode连接M3内核与Flash接口。</p> <h3 id="_10-2-dcode"><a href="#_10-2-dcode" class="header-anchor">#</a> 10.2 DCode</h3> <p>该总线将CortexTM-M3内核的DCode总线与闪存存储器的数据接口相连接(常量加载和调试访问)。</p> <p>DCode 中的D 表示Data，即数据，那说明这条总线是用来取数的。我们在写程序的时候，数据有常量和变量两种，常量就是固定不变的，用C 语言中的const 关键字修饰，是放到内部的FLASH 当中的，变量是可变的，不管是全局变量还是局部变量都放在内部的SRAM。因为数据可以被Dcode 总线和DMA 总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。</p> <h3 id="_10-3-system-bus"><a href="#_10-3-system-bus" class="header-anchor">#</a> 10.3 system bus</h3> <p>System Bus是一个由多个总线组成的系统级总线，用于连接处理器核心和系统中其他设备和组件，例如内存、外设、DMA控制器、中断控制器等。</p> <p>System Bus的主要功能是提供高带宽和低延迟的数据传输。它通常由多个独立的总线组成，包括数据总线、地址总线和控制总线。这些总线共同协作，实现处理器核心与其他系统组件之间的数据传输和控制信号的交互。</p> <h3 id="_10-4-dma-总线"><a href="#_10-4-dma-总线" class="header-anchor">#</a> 10.4 DMA 总线</h3> <p>DMA是把一个地址的数据搬运到另外一个地址，所以它需要控制地址，这些地址在处理器内部是AHB和APB总线矩阵管理的，所以DMA必须要挂到AHB和APB上面</p> <p>DMA（Direct Memory Access）总线是一种用于高速数据传输的专用总线。它可以在不需要处理器的干预下，直接从外设设备中读取或写入数据到内存中。DMA总线通过减轻CPU的负担，提高数据传输的速度和效率，使系统更加高效和可靠。</p> <h3 id="_10-5-总线矩阵"><a href="#_10-5-总线矩阵" class="header-anchor">#</a> 10.5 总线矩阵</h3> <p>总线矩阵协调内核系统总线和DMA主控总线之间的访问仲裁,仲裁利用轮换算法。在互联型产品中,总线矩阵包含5个驱动部件(CPU的DCode、系统总线、以太网DMA、DMA1总线和DMA2总线)和3个从部件(闪存存储器接口(FLITF)、SRAM和AHB2APB桥)。在其它产品中总线矩阵包含4个驱动部件(CPU的DCode、系统总线、DMA1总线和DMA2总线)和4个被动部件(闪存存储器接口(FLITF)、SRAM、FSMC和AHB2APB桥)。</p> <p>AHB外设通过总线矩阵与系统总线相连,允许DMA访问。</p> <h2 id="_11-rcc-是什么"><a href="#_11-rcc-是什么" class="header-anchor">#</a> 11 RCC 是什么？</h2> <p>Reset Clock Control，复位时钟控制，控制提供给各模块时钟信号的通断。</p> <p>可开启或关闭各总线的时钟，在使用各外设功能必须先开启其对应的时钟，没有这个时钟内部的各器件就不能运行。 RTC是 STM32 内部集成的一个简单的时钟 (计时用)，如果不用就关闭，用的话先要通过 RCC 配置其时钟源，可看作是一个外设器件。</p> <h2 id="_12-为什么-32-位-cpu-地址总线一般不超过-32"><a href="#_12-为什么-32-位-cpu-地址总线一般不超过-32" class="header-anchor">#</a> 12 为什么 32 位 cpu 地址总线一般不超过 32 ？</h2> <p>32 位的 CPU 数据总线宽度是 32 位，即 4 字节。</p> <p>通常情况下，地址总线宽度要小于数据总线宽度，数据总线宽度决定了 CPU 的一个时钟周期内可以处理的数据量大小。
而数据总线宽度大小应该根据 CPU 支持的操作数大小来设计，通常地址总线宽度小于数据总线宽度，以便于
CPU 高效传输数据。</p> <p>通常情况下，数据总线宽度与处理器架构所支持的最大数据宽度相匹配，以提供最佳的性能和效率。</p> <p>增加地址总线宽度会增加芯片的复杂性和成本。因为需要更多的信号线和支持电路来传输和处理更多的地址位数。此外，处理器的寄存器也需要更多的位数来处理更大的地址，这会增加处理器的功耗和成本。</p> <p>数据总线长度小于字长的话，会浪费 CPU 的处理能力，大于字长的话，地址数据 CPU 一次处理不完，
会影响效率，导致访存速度降低，寻址空间变大了，但是寻址速度变慢了，所以一般 数据总线的长度等于字长。</p> <p>指针的长度一般等于地址总线的宽度。</p> <h2 id="_13-uart-和-usart-有什么区别"><a href="#_13-uart-和-usart-有什么区别" class="header-anchor">#</a> 13 UART 和 USART 有什么区别？</h2> <p>UART 通用异步收发器</p> <p>USART 通用同步/异步收发器</p> <h2 id="_14-rtc-和-rcc-的区别"><a href="#_14-rtc-和-rcc-的区别" class="header-anchor">#</a> 14 RTC 和 RCC 的区别</h2> <p>RCC 是 stm32 的时钟控制器，RTC 是 stm32 内部集成的一个简单的时钟。</p> <h2 id="_15-哈佛架构eh冯诺依曼架构的区别"><a href="#_15-哈佛架构eh冯诺依曼架构的区别" class="header-anchor">#</a> 15 哈佛架构eh冯诺依曼架构的区别？</h2> <p>哈佛架构和冯诺依曼架构是两种不同的CPU设计思路，主要区别在于程序指令和数据是如何存储和传输的。</p> <p>冯诺依曼架构认为CPU通过一组总线来分时获取指令和数据，指令和数据都存储在同一个存储器中，共享同一个地址空间。² 这种结构实现简单，成本低，但是也造成了信息流的传输瓶颈，影响了数据处理速度的提高。</p> <p>哈佛架构认为CPU应该分别通过两组独立的总线来对接指令和数据，指令和数据分别存储在不同的存储器中，拥有不同的地址空间。¹² 这种结构可以使指令和数据有不同的数据宽度，同时取指和取数，提高了运算效率，但是也增加了复杂度和对外围设备的要求。</p> <p>ARM是一种改进型的哈佛架构，它使用了内部缓存（cache）来存放指令和数据，而且指令缓存和数据缓存是分开的。¹ 这样既保留了哈佛架构的优点，又克服了冯诺依曼结构的缺点。</p> <p>源: 与必应的对话， 2023/5/15
(1) ARM到底是冯诺依曼结构还是哈佛结构 - 知乎 - 知乎专栏. https://bing.com/search?q=%e5%93%88%e4%bd%9b%e6%9e%b6%e6%9e%84%e5%92%8c%e5%86%af%e8%af%ba%e4%be%9d%e6%9b%bc%e6%9e%b6%e6%9e%84%e7%9a%84%e5%8c%ba%e5%88%ab.
(2) 哈佛结构和冯诺依曼结构 - 知乎 - 知乎专栏. https://zhuanlan.zhihu.com/p/85847486.
(3) 冯诺依曼与哈佛结构的区别 - CSDN博客. https://blog.csdn.net/zhangwenchaochao/article/details/91047661.
(4) ARM到底是冯诺依曼结构还是哈佛结构 - 知乎 - 知乎专栏. https://zhuanlan.zhihu.com/p/126269758.
(5) 冯诺依曼结构和哈佛结构之间的区别 - 百度知道. https://zhidao.baidu.com/question/333521852.html.</p> <h2 id="_16-哈佛架构和冯诺依曼架构的适用场景"><a href="#_16-哈佛架构和冯诺依曼架构的适用场景" class="header-anchor">#</a> 16 哈佛架构和冯诺依曼架构的适用场景</h2> <p>哈佛架构和冯诺依曼架构的适用场景各有不同，主要取决于程序指令和数据的存储和访问需求。</p> <p>冯诺依曼架构主要用于通用计算机领域，需要对存储器中的代码和数据频繁的进行修改，统一编址有利于节约资源。¹² 但是，这种结构也导致了指令和数据共享同一总线，造成了信息流的传输瓶颈，影响了数据处理速度的提高。</p> <p>哈佛架构主要用于嵌入式计算机，程序固化在硬件中，有较高的可靠性、运算速度和较大的吞吐量。¹² 这种结构可以使指令和数据分别经由不同的存储空间和不同的总线，同时取指和取数，提高了运算效率，但是也增加了复杂度和对外围设备的要求。</p> <p>ARM是一种改进型的哈佛架构，它使用了内部缓存（cache）来存放指令和数据，而且指令缓存和数据缓存是分开的。⁴ 这样既保留了哈佛架构的优点，又克服了冯诺依曼结构的缺点。⁴ ARM适用于需要高性能、低功耗、多任务处理的场景，如智能手机、平板电脑、物联网等。</p> <p>源: 与必应的对话， 2023/5/15
(1) 哈佛结构&amp;冯·诺依曼结构 - 知乎 - 知乎专栏. https://zhuanlan.zhihu.com/p/615523283.
(2) 哈佛结构和冯诺依曼结构 - 知乎 - 知乎专栏. https://zhuanlan.zhihu.com/p/85847486.
(3) 一套用了 70 年的计算机架构 —— 冯·诺依曼架构 - 知乎. https://zhuanlan.zhihu.com/p/581546247.
(4) 哈佛结构还是冯诺依曼结构的特点有哪些 - 开发技术 - 亿速云. https://www.yisu.com/zixun/483127.html.
(5) STM32属于哈佛结构还是冯诺依曼结构？ - 知乎 - 知乎专栏. https://zhuanlan.zhihu.com/p/368910734.</p> <h2 id="_17-看门狗是什么"><a href="#_17-看门狗是什么" class="header-anchor">#</a> 17 看门狗是什么？</h2> <p>嵌入式看门狗是一种专门用于监测系统程序运行状态的芯片或程序，俗称&quot;看门狗&quot; (watchdog)。在嵌入式系统中，由于MCU常常会受到来自外界电磁场的干扰，造成程序跑飞而陷入死循环，无法继续工作，整个系统陷入停滞状态，发生不可预料的后果，所以出于对运行状态进行实时监测的考虑，便产生了一种专门用于监测系统程序运行状态的芯片或程序，俗称&quot;看门狗&quot; (watchdog) ¹。</p> <p>希望这可以回答您的问题。如果您有其他问题，请随时问我！</p> <p>源: 与必应的对话， 2023/5/15
(1) 嵌入式主板的“看门狗“功能是指什么 - 百度知道. https://bing.com/search?q=%e5%b5%8c%e5%85%a5%e5%bc%8f%e7%9c%8b%e9%97%a8%e7%8b%97%e6%98%af%e4%bb%80%e4%b9%88.
(2) 看门狗原理_硬件看门狗的工作原理_kuniqiw的博客-CSDN博客. https://blog.csdn.net/kuniqiw/article/details/113098733.
(3) 谈谈看门狗在嵌入式中的用法 - 简书. https://www.jianshu.com/p/cf6f6316565c.
(4) 基于嵌入式系统中看门狗的原理与使用 - 电子发烧友网. https://www.elecfans.com/d/632710.html.
(5) STM32 看门狗详解 - 知乎 - 知乎专栏. https://zhuanlan.zhihu.com/p/349094185.
(6) 一篇文章搞定嵌入式看门狗watch dog概述与示例代码_看门狗代码_木头人i的博客-CSDN博客. https://blog.csdn.net/weixin_43332735/article/details/108862690.</p> <h2 id="_18-integer-operation-result-is-out-of-range"><a href="#_18-integer-operation-result-is-out-of-range" class="header-anchor">#</a> 18 integer operation result is out of range</h2> <div class="language-c line-numbers-mode"><pre class="language-c"><code>    GPIOC<span class="token operator">-&gt;</span>CRL <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0xff</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>编译后编译器报错：</p> <p><code>integer operation result is out of range (61-D)</code>，经查资料是由于溢出所致，<strong>宏定义默认常量是有符号型</strong>，
当 <code>0xff</code> 左移 24 位时，常数就变成负数，编译器就会给出如上的警告信息解决办法是强制类型转换成无符号类型:</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>GPIOC<span class="token operator">-&gt;</span>CRL <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xff</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_19-波特率和比特率"><a href="#_19-波特率和比特率" class="header-anchor">#</a> 19 波特率和比特率</h2> <p>波特（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。</p> <p>它是对符号传输速率的一种度量，1波特即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。</p> <p>“波特”（Baud）本身已是速率，所以不需要写成 Baud Rate（Rate 是赘字）。单位“波特”本身就已经是代表每秒的调制数，以“波特每秒”（Baud per second）为单位是一种常见的错误，但是在一般中文口语化的沟通上还是常以“波特率”来描述“波特”（Baud）</p> <p>比特率：对信息传输速率（传信率）的度量</p> <p>波特率：单位时间内传输符号的个数（传符号率）</p> <p>如果在数字传输过程中，用0V表示数字0，5V表示数字1，那么每个码元有两种状态0和1. 每个码元代表一个二进制数字。此时的每秒码元数和每秒二进制代码数是一样的，这叫两相调制，波特率等于比特率。</p> <p>如果在数字传输过程中，0V、2V、4V和6V分别表示00、01、10和11，那么每个码元有四种状态00、01、10和11. 每个码元代表两个二进制数字。此时的每秒码元数是每秒二进制代码数是一半的，这叫四相调制，波特率等于比特率一半。</p> <p>1波特 = 1位/秒，1baud = 1 bit/s</p> <p>两者关系</p> <p>波特率与比特率的关系为：比特率=波特率X单个调制状态对应的二进制位数</p> <p>I = S * log<sub>2</sub>N</p> <h2 id="_20-中断和函数的区别"><a href="#_20-中断和函数的区别" class="header-anchor">#</a> 20 中断和函数的区别</h2> <p>中断：</p> <ol><li>何时发生是不可预料的。</li> <li>对于可剥夺型内核，完成中断调度后不是立刻返回原来的执行点执行，而是回到就绪态优先级最高的任务开始执行。</li> <li>没有返回值。</li> <li>不能传递参数。</li></ol> <p>函数：</p> <ol><li>何时发生是可以预料的。</li> <li>完成函数调度后会返回原来的代码片段继续执行。</li> <li>有返回值。</li> <li>能传递参数。</li></ol> <p>相同点：</p> <ol><li>再执行调度之前，都会保存现场。</li> <li>都是调用一个 subcode。</li></ol> <h2 id="_21-中断和事件的区别"><a href="#_21-中断和事件的区别" class="header-anchor">#</a> 21 中断和事件的区别</h2> <p>从外部激励信号来看,中断和事件的产生源都可以是一样的.之所以分成2个部分,由于中断是需要CPU参与的,需要软件的中断服务函数才能完成中断后产生的结果;</p> <p>但是事件,是靠脉冲发生器产生一个脉冲,进而由硬件自动完成这个事件产生的结果,当然相应的联动部件需要先设置好,比如引起DMA操作,AD转换等;</p> <p>简单举例：外部I/O触发AD转换,来测量外部物品的重量;如果使用传统的中断通道,需要I/O触发产生外部中断,外部中断服务程序启动AD转换,AD转换完成中断服务程序提交最后结果;</p> <p>要是使用事件通道,I/O触发产生事件,然后联动触发AD转换,AD转换完成中断服务程序提交最后结果;相比之下,后者不要软件参与AD触发,并且响应速度也更块;</p> <p>要是使用事件触发DMA操作,就完全不用软件参与就可以完成某些联动任务了。</p> <p>可以这样简单的认为,事件机制提供了一个完全由硬件自动完成的触发到产生结果的通道,不要软件的参与,降低了CPU的负荷,节省了中断资源，提高了响应速度(硬件总快于软件)，是利用硬件来提升CPU芯片处理事件能力的一个有效方法。</p> <h2 id="_22-什么时候需要开启-afio-时钟"><a href="#_22-什么时候需要开启-afio-时钟" class="header-anchor">#</a> 22 什么时候需要开启 AFIO 时钟？</h2> <p>根据参考手册：</p> <ol><li>事件控制寄存器</li> <li>复用重映射和调试 I/O 配置寄存器</li> <li>外部中断配置寄存器1</li> <li>外部中断配置寄存器2</li> <li>外部中断配置寄存器3</li> <li>外部中断配置寄存器3</li></ol> <p>只有需要用到重映射、时间寄存器、配置寄存器、外部中断时需要打开 AFIO 时钟，引脚复用时不用打开。</p> <h2 id="_23-stm32-部分重映射和完全重映射有什么区别"><a href="#_23-stm32-部分重映射和完全重映射有什么区别" class="header-anchor">#</a> 23 stm32 部分重映射和完全重映射有什么区别？</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">2023/4/19 20:48:31</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.a9cbc012.js" defer></script><script src="/wiki/assets/js/2.4b7299de.js" defer></script><script src="/wiki/assets/js/30.710f9039.js" defer></script>
  </body>
</html>
