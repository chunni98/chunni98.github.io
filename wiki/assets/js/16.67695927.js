(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{291:function(t,_,s){"use strict";s.r(_);var v=s(14),a=Object(v.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_3-1-为什么栈空间很小"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-为什么栈空间很小"}},[t._v("#")]),t._v(" 3.1 为什么栈空间很小？")]),t._v(" "),s("p",[t._v("C的栈在 "),s("code",[t._v("x86-64")]),t._v(" 上是直接绑定到CPU指令的，实现上极其精简，因此它与堆不同，没有动态增长、动态缩小的功能，一旦分配出来就会永远占用相应的空间。每个线程都会占用独立的栈空间，这样对于线程数很多的进程来说，如果栈空间分配得过多，就会很浪费内存空间。相反，堆空间可以一开始分配得很小，然后不停向上增长，释放相应的空间之后还可以归还给操作系统，因此适合处理比较大的空间。对于一定要占用比较大的栈空间的情况，可以指定栈空间大小。其他语言的栈并不一定是这样的，比如Python的栈就是假的，用堆空间模拟的，只有递归深度限制，而没有容量限制。")]),t._v(" "),s("h2",{attrs:{id:"_3-2-什么时候使用-short"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-什么时候使用-short"}},[t._v("#")]),t._v(" 3.2 什么时候使用 short？")]),t._v(" "),s("p",[t._v("通常 "),s("code",[t._v("int")]),t._v(" 设置为自然大小，是硬件处理效率最高的整数形式。")]),t._v(" "),s("p",[s("code",[t._v("short")]),t._v(" 在参与运算时会被转成 "),s("code",[t._v("int")]),t._v("，会影响处理"),s("code",[t._v("short")]),t._v("整型运算速度。")]),t._v(" "),s("p",[t._v("在"),s("code",[t._v("C/C++")]),t._v("中，编译器对"),s("code",[t._v("int")]),t._v("类型数据的执行效率最高。一般在符合int条件的情况下优先选择int")]),t._v(" "),s("h2",{attrs:{id:"_3-3-unsigned-陷阱"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-unsigned-陷阱"}},[t._v("#")]),t._v(" 3.3 unsigned 陷阱")]),t._v(" "),s("p",[t._v("有符号数和无符号数相加时，有符号数的类型被提升到无符号数，最高位符号位变成数据位。")]),t._v(" "),s("h2",{attrs:{id:"_3-4-形参设为-const-指针有什么好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-形参设为-const-指针有什么好处"}},[t._v("#")]),t._v(" 3.4 形参设为 const 指针有什么好处？")]),t._v(" "),s("p",[t._v("将形参设置为const将把形参限定为常量，使得我们不能修改它。")]),t._v(" "),s("p",[t._v("这样做的好处有2点：")]),t._v(" "),s("ul",[s("li",[t._v("第一，保证了实参不能被修改，增加了安全性。")]),t._v(" "),s("li",[t._v("第二，扩大了该函数的参数的接收范围，使得函数更具通用性")])]),t._v(" "),s("h2",{attrs:{id:"_3-5-scanf里的空白符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-scanf里的空白符"}},[t._v("#")]),t._v(" 3.5 scanf里的空白符")]),t._v(" "),s("p",[t._v("空白字符能匹配输入中任意数量的空白符，所以"),s("code",[t._v('scanf("\\n"）')]),t._v("里的 "),s("code",[t._v("\\n")]),t._v(" 能匹配任意数量的空白符。scanf会一直等待输入，直到输入非空白符为止。")])])}),[],!1,null,null,null);_.default=a.exports}}]);