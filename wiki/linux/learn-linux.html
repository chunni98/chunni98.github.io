<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1 Linux 笔记 | CS Wiki</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="shachi 的 CS 知识库">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.9336cb57.css" as="style"><link rel="preload" href="/wiki/assets/js/app.c0bed5a9.js" as="script"><link rel="preload" href="/wiki/assets/js/2.4b7299de.js" as="script"><link rel="preload" href="/wiki/assets/js/8.7988023b.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.ae7abe52.js"><link rel="prefetch" href="/wiki/assets/js/11.ea74e48c.js"><link rel="prefetch" href="/wiki/assets/js/12.abf2163e.js"><link rel="prefetch" href="/wiki/assets/js/13.cd38d44b.js"><link rel="prefetch" href="/wiki/assets/js/14.e031df53.js"><link rel="prefetch" href="/wiki/assets/js/15.58d1f635.js"><link rel="prefetch" href="/wiki/assets/js/16.67695927.js"><link rel="prefetch" href="/wiki/assets/js/17.64bf9856.js"><link rel="prefetch" href="/wiki/assets/js/18.58bbd21f.js"><link rel="prefetch" href="/wiki/assets/js/19.8c1667c4.js"><link rel="prefetch" href="/wiki/assets/js/20.14a77fb3.js"><link rel="prefetch" href="/wiki/assets/js/21.0fdf1654.js"><link rel="prefetch" href="/wiki/assets/js/22.a3a63be4.js"><link rel="prefetch" href="/wiki/assets/js/23.1331ee9c.js"><link rel="prefetch" href="/wiki/assets/js/24.45725f5b.js"><link rel="prefetch" href="/wiki/assets/js/25.4b1178ec.js"><link rel="prefetch" href="/wiki/assets/js/26.400daf7c.js"><link rel="prefetch" href="/wiki/assets/js/27.ab26ea35.js"><link rel="prefetch" href="/wiki/assets/js/28.9f6cb629.js"><link rel="prefetch" href="/wiki/assets/js/29.6d7b45bc.js"><link rel="prefetch" href="/wiki/assets/js/3.1354b53b.js"><link rel="prefetch" href="/wiki/assets/js/30.e3c77825.js"><link rel="prefetch" href="/wiki/assets/js/4.e3173cf0.js"><link rel="prefetch" href="/wiki/assets/js/5.cd37ab94.js"><link rel="prefetch" href="/wiki/assets/js/6.3b848e60.js"><link rel="prefetch" href="/wiki/assets/js/7.391a926e.js"><link rel="prefetch" href="/wiki/assets/js/9.155775f2.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.9336cb57.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><img src="/wiki/favicon.ico" alt="CS Wiki" class="logo"> <span class="site-name can-hide">CS Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  数据库
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  python
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/Linux/.html#" class="nav-link">
  x86汇编
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  数据库
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  python
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/Linux/.html#" class="nav-link">
  x86汇编
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/wiki/Linux/" aria-current="page" class="sidebar-link">Linux 笔记</a></li><li><a href="/wiki/Linux/learn-linux.html" aria-current="page" class="active sidebar-link">1 Linux 笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-1-gnu-c-complier" class="sidebar-link">1.1 GNU C Complier</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-2-动态链接库和静态链接库" class="sidebar-link">1.2 动态链接库和静态链接库</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-3-gnu-symbolic-debugger" class="sidebar-link">1.3 GNU  Symbolic Debugger</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-4-包管理工具-apt-和-dpkg" class="sidebar-link">1.4 包管理工具 apt 和 dpkg</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-5-输入输出重定向" class="sidebar-link">1.5 输入输出重定向</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-6-常用命令" class="sidebar-link">1.6 常用命令</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-7-elf-文件" class="sidebar-link">1.7 ELF 文件</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-8-常见服务" class="sidebar-link">1.8 常见服务</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-9-进程" class="sidebar-link">1.9 进程</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-10-linux-下的进程管理" class="sidebar-link">1.10 Linux 下的进程管理</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-11-内核空间和用户空间" class="sidebar-link">1.11 内核空间和用户空间</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-12-命令置换" class="sidebar-link">1.12 命令置换</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-13-exec-函数族" class="sidebar-link">1.13 exec 函数族</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-14-ext4-文件系统" class="sidebar-link">1.14 ext4 文件系统</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-15-文件锁" class="sidebar-link">1.15 文件锁</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-16-进程的结束" class="sidebar-link">1.16 进程的结束</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-17-守护进程" class="sidebar-link">1.17 守护进程</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-18-进程和线程的选择与区别" class="sidebar-link">1.18 进程和线程的选择与区别</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-19-dup-和-dup2" class="sidebar-link">1.19 dup() 和 dup2()</a></li></ul></li><li><a href="/wiki/Linux/linux-collections.html" class="sidebar-link">2 Linux 问题集</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/Linux/unix-programing/" class="sidebar-heading clickable"><span>Unix 环境编程</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-1-gnu-c-complier"><a href="#_1-1-gnu-c-complier" class="header-anchor">#</a> 1.1 GNU C Complier</h2> <p>gcc/g++指令选项	功 能</p> <ul><li><code>-E</code>（大写）	预处理指定的源文件，不进行编译。</li> <li><code>-S</code>（大写）	编译指定的源文件，但是不进行汇编。</li> <li><code>-c</code>	编译、汇编指定的源文件，但是不进行链接。</li> <li><code>-o</code>	指定生成文件的文件名。</li> <li><code>-llibrary</code>	其中 library 表示要搜索的库文件的名称。该选项用于手动指定链接环节中程序可以调用的库文件。建议 -l 和库文件名之间不使用空格，比如 -lstdc++。</li></ul> <p>注意，使用-l选项指明静态库的名字时，既不需要lib前缀，也不需要.a后缀，只能写 test，GCC 会自动加上前缀和后缀。</p> <ul><li><code>-L &lt;path&gt;</code> 指定库路径。</li> <li><code>-I &lt;path&gt;</code> 指定头文件路径。</li> <li><code>-ansi</code>	对于 C 语言程序来说，其等价于 -std=c90；对于 C++ 程序来说，其等价于 -std=c++98。</li> <li><code>-std=</code>	手动指令编程语言所遵循的标准，例如 c89、c90、c++98、c++11 等。</li> <li><code>-D</code> 处理源文件前定义一个宏。</li> <li><code>-U</code> 取消宏定义。</li> <li><code>-g</code> 生成可调式文件。</li> <li><code>-O2</code> 比 <code>-O</code> 更好的优化编译。</li> <li><code>-MM</code> 查看文件的依赖（非标准库）</li> <li><code>Wall</code> 打开所有警告。</li> <li><code>Wextra</code> 启用一些未由-Wall启用的额外警告标志。</li> <li><code>Wvla</code> 警告动态数组的使用。</li> <li><code>Werror</code> 把所有的警告当作错误处理。</li> <li><code>static</code> 强制使用同名静态库，并且链接到的所有库都用静态编译。谨慎使用。</li> <li><code>-pedantic</code> 以ANSI/ISO C标准列出的所有警告，使用了扩展语法的地方将会产生警告。</li> <li><code>-ansi</code></li> <li><code>-std=c99</code>，c 99 标准。</li></ul> <h2 id="_1-2-动态链接库和静态链接库"><a href="#_1-2-动态链接库和静态链接库" class="header-anchor">#</a> 1.2 动态链接库和静态链接库</h2> <h3 id="_1-2-1-创建静态链接库"><a href="#_1-2-1-创建静态链接库" class="header-anchor">#</a> 1.2.1 创建静态链接库</h3> <p><code>ar rcs + 静态库文件的名字 + 目标文件列表</code></p> <p>如<code>ar rcs libtest.a *.o</code></p> <p>ar 是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件。ar 命令最常见的用法是将目标文件打包为静态链接库。</p> <p>对参数的说明：</p> <ul><li>参数 <code>r</code> 用来替换库中已有的目标文件，或者加入新的目标文件。</li> <li>参数 <code>c</code> 表示创建一个库。不管库否存在，都将创建。</li> <li>参数 <code>s</code> 用来创建目标文件索引，这在创建较大的库时能提高速度。</li> <li>参数 <code>v</code> 用</li> <li><code>d</code> 从归档文件中删除</li> <li><code>t</code> 查看归档文件的内容</li> <li><code>x</code> 解压归档文件</li> <li><code>a/b</code> 向归档文件中添加内容</li> <li><code>v</code> 显示详细信息</li></ul> <p><code>ar rcsv libxxx.a *.o</code></p> <h3 id="_1-2-2-创建动态链接库"><a href="#_1-2-2-创建动态链接库" class="header-anchor">#</a> 1.2.2 创建动态链接库</h3> <p><code>gcc 源文件(*.c) -c -fpic -Wall</code></p> <p><code>gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)</code></p> <p><code>-fPIC</code> 是创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。<code>-shared</code> 指定生成动态链接库。</p> <p>态库必须拷贝放在/usr/lib目录或/lib目录中，才可以使用。如果不想拷贝的话，可以在之前系统lib目录下生成一个动态库的软链接。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># 发布
 	1. 提供头文件: xxx.h
 	2. 提供动态库: libxxx.so
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>动态库如果安装在/lib或者/usr/lib下，那么 ld 默认能够找到</p> <p>或者将文件路径保存到 <code>/etc/ld.so.conf</code> 中。执行 <code>ldconfig</code> 命令，将 <code>/etc/ld.so.conf</code> 中保存的库路径写入 <code>/etc/ld.so.cache</code>。</p> <p><code>LD_LIBRARY_PATH</code> 环境变量保存库路径。</p> <p>ld.so 接口。</p> <p>静态库和动态库的载入时间是不一样的。</p> <p>静态库的代码在编译的过程中已经载入到可执行文件中，所以最后生成的可执行文件相对较大。</p> <p>动态库的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，所以最后生成的可执行文件相对较小。</p> <p>静态库和动态库的最大区别是，静态库链接的时候把库直接加载到程序中,而动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度。</p> <h2 id="_1-3-gnu-symbolic-debugger"><a href="#_1-3-gnu-symbolic-debugger" class="header-anchor">#</a> 1.3 GNU  Symbolic Debugger</h2> <p>TODO: 多线程调试。</p> <p>GDB调试主要有三种方式：</p> <p>直接调试目标程序：<code>gdb ./hello_server</code></p> <p>附加进程id：<code>gdb attach pid</code></p> <p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他，如果GDB attach某个进程，退出GDB之前要用命令 detach 解除附加进程。</p> <p>调试core文件：<code>gdb filename corename</code></p> <p>用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</p> <p><code>--core=COREFILE</code> 调试时core dump的core文件。</p> <p>gdb 内命令：</p> <p><code>list</code> 列出源文件，回车继续列出。</p> <p><code>break num</code> 在 num 行处设置断点。</p> <p><code>break funcname</code> 在函数入口处设置断点。</p> <p><code>break filename:funcname</code></p> <p><code>info break</code> 查看断点信息。</p> <p><code>run</code> 运行程序。</p> <p><code>next</code> 单条语句执行</p> <p><code>continue</code> 继续运行程序直到下一个断点。</p> <p><code>print</code> 查看变量当前的值。</p> <p><code>print param=value</code>，用于在调试过程中修改变量的值；</p> <p><code>print func()</code>，输出func函数执行的结果，常见的用途是打印系统函数执行失败原因：print strerror(errno)；</p> <p><code>ptype val</code> 打印变量类型。print type</p> <p><code>step</code> step in，如果有函数调用，他会进入该函数。</p> <p><code>next</code> step out，不会进入函数调用。</p> <p><code>bt</code> backtrace 查看函数堆栈。</p> <p><code>f n</code> frame 切换堆栈。</p> <p><code>return val</code> 命令是立即退出当前函数，剩下的代码不会执行了，return 还可以指定函数的返回值</p> <p><code>finish</code> 运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。</p> <p><code>watch expr</code> 设置观察点，<code>expr</code> 值变化时停住程序。<code>awatch expr</code> 当值被读或被写的时候停住程序。</p> <p><code>watch *指针变量</code>，监视的是指针所指的内容；</p> <p><code>clear</code> 清除所有停止点。<code>clear num</code> 清除指定行的停止点，<code>clear filenam:linenum</code> 清除指定文件指定行的停止点。</p> <p><code>disable [breakpoints] [range...]</code> 暂停所指定的停止点。</p> <p><code>enable [breadpoints] [range...]</code> 使能所有停止点。</p> <p><code>quit</code> 退出</p> <h2 id="_1-4-包管理工具-apt-和-dpkg"><a href="#_1-4-包管理工具-apt-和-dpkg" class="header-anchor">#</a> 1.4 包管理工具 apt 和 dpkg</h2> <h3 id="_1-4-1-软件源配置文件"><a href="#_1-4-1-软件源配置文件" class="header-anchor">#</a> 1.4.1 软件源配置文件</h3> <p><code>/etc/apt/sources.list</code></p> <p>软件源是指互联网中的众多服务器，这些服务器上存放了大量的软件包，可用于用户主机的更新和升级。</p> <h3 id="_1-4-2-apt-get"><a href="#_1-4-2-apt-get" class="header-anchor">#</a> 1.4.2 apt-get</h3> <p><code>apt-get</code> 用于管理软件包，包括安装、卸载、升级等。</p> <ul><li><code>update</code> 刷新软件源，下载更新软件包列表信息。</li> <li><code>upgrade</code> 将系统中所有软件包升级到最新版本。</li> <li><code>install</code> 下载所需软件包并进行安装配置。</li> <li><code>remove</code> 卸载软件包。</li> <li><code>autoremove</code> 将不满足依赖关系的软件包自动卸载。</li> <li><code>source</code> 下载源码包。</li> <li><code>clean</code> 删除缓存区中所有已下载的包文件。</li> <li><code>autoclean</code> 删除缓存区中老版本的已下载的包文件。</li> <li><code>check</code> 检查系统中依赖关系的完整性。</li> <li><code>--purge</code> 与 <code>remove</code> 一起使用，完全卸载软件包，同时删除该软件包所使用的配置文件。</li> <li><code>-s</code> 不做实际操作，只是模拟命令执行结果。</li> <li><code>-f</code> 修复系统中存在的软件包依赖性问题。</li></ul> <p><code>apt-get check</code> <code>apt-get -f install</code> 通常作为组合命令使用，前者用于检查软件包依赖关系，后者用于修复依赖关系。</p> <p>经常使用 <code>apt-get update</code> 刷新软件源可保持软件源最新。该命令会为服务器具有的软件包资源j</p> <p>查询安装包大小：<code>apt-cache show &lt;package&gt; | grep &quot;Size&quot;</code></p> <h3 id="_1-4-3-dpkg"><a href="#_1-4-3-dpkg" class="header-anchor">#</a> 1.4.3 dpkg</h3> <p><code>dpkg -r &lt;package&gt;</code> 移除一个已安装的软件包。</p> <p><code>dpkg -i &lt;package&gt;</code> 离线安装。</p> <p><code>dpkg -p &lt;package&gt;</code> 移除已安装软件包以及配置文件。</p> <p><code>dpkg -L &lt;package&gt;</code> 列出安装的软件包清单。</p> <p><code>dpkg-reconfigure &lt;package&gt;</code> 重新配置一个已安装的软件包。</p> <h2 id="_1-5-输入输出重定向"><a href="#_1-5-输入输出重定向" class="header-anchor">#</a> 1.5 输入输出重定向</h2> <p>标准输入 0，默认是键盘，标准输出 1，默认是终端，标准错误输出 2，默认是终端。</p> <p><code>command &lt; file</code> 将 <code>file</code> 重定向为输入源。</p> <p><code>command &gt; file</code> 将 <code>file</code> 重定向为输出源。</p> <p><code>command &gt;&gt; file</code> ，将 <code>file</code> 重定向为输出源，追加模式。</p> <p><code>command 2&gt; file</code> 将 <code>file</code> 重定向为标准错误源。</p> <p><code>command 2&gt;&gt; file</code> 将 <code>file</code> 重定向为标准错误源，追加模式。</p> <p><code>command &amp;&gt;&gt; file</code> 将 <code>file</code> 重定向为标准输出源和标准错误源，等同于 <code>&gt;&gt;&amp;</code> ，标准输出与标准错误输出全部重定向。</p> <p><code>command &gt;&gt; file1 2&gt;&gt; file2</code> 将 <code>file1</code> 重定向为标准标准输出源，将 <code>file2</code> 重定向为标准错误。</p> <p><code>command &gt; file1 2&gt;&amp;1</code> 将标准错误输出转成标准输出。</p> <p><code>&amp;&gt; /dev/null</code> 重定向到 <code>null</code>。</p> <p>输入输出重定向就是取代了键盘屏幕,能够接受键盘输入的都可以用重定向改为文件输入,能够输出到屏幕的,都可以通过重定向保存到文件。</p> <p>而管道符可以把标准输出转标准输入,以让可以接受标准输入的命令可以以此为输入执行命令,所以说,重定向也可以做到同样的事情,但一般来说不会这么做,就像cat,默认以文件名为参数,没有文件名才从标准输入读。</p> <p>定向的作用对象只能是文件。</p> <h2 id="_1-6-常用命令"><a href="#_1-6-常用命令" class="header-anchor">#</a> 1.6 常用命令</h2> <p>ls,cd,mv,cp,rm,mkdir,echo,date,pwd,clear,who,man,shutdown,passwd,su,top,pstree</p> <h3 id="_1-6-1-cat"><a href="#_1-6-1-cat" class="header-anchor">#</a> 1.6.1 cat</h3> <p><code>cat</code> 等待输入，按<code>&lt;enter&gt;</code> 键后输出到标准输出。</p> <p><code>cat &lt; file</code> 将file 的内容输出到标准输出。（默认是终端）</p> <p><code>cat &gt; file</code> 将输入的内容重定向到 file 中。</p> <h3 id="_1-6-2-less"><a href="#_1-6-2-less" class="header-anchor">#</a> 1.6.2 less</h3> <p>是一个分页显示工具。</p> <p><code>less</code> 命令主要用于打开大文件，<code>less</code> 不会读取整个文件，相比于 vim 或 nano 等文本编辑器，加载时间会更快。</p> <p><code>C-f</code> 翻页，<code>C-b</code> 翻页。</p> <p><code>-N</code> 打印行号。</p> <p><code>-m</code> 显示百分比。</p> <p><code>/&lt;pattern&gt;</code> 搜索 <code>&lt;pattern&gt;</code>，操作使用 <code>vi</code> 模式。<code>n</code>、<code>N</code>、<code>?</code> 。</p> <p><code>pa -aux | less</code></p> <h3 id="_1-6-3-wahtis"><a href="#_1-6-3-wahtis" class="header-anchor">#</a> 1.6.3 wahtis</h3> <p>等同于 <code>man -f</code> 。显示来自手册页的加简短说明(若有)。</p> <h3 id="_1-6-4-mount"><a href="#_1-6-4-mount" class="header-anchor">#</a> 1.6.4 mount</h3> <p>临时挂载分区</p> <h3 id="_1-6-5-umount"><a href="#_1-6-5-umount" class="header-anchor">#</a> 1.6.5 umount</h3> <p>卸载一个文件系统，就是从系统目录结构中，移去该指定的文件系统，卸载后的文件系统不能被用户使用。</p> <h3 id="_1-6-6-find"><a href="#_1-6-6-find" class="header-anchor">#</a> 1.6.6 find</h3> <h3 id="_1-6-7-du"><a href="#_1-6-7-du" class="header-anchor">#</a> 1.6.7 du</h3> <p>报告磁盘空间使用情况。</p> <p><code>-h</code> 以最常见的格式显示出大小。</p> <p><code>-T</code> 显示文件类型。</p> <h3 id="_1-6-8-df"><a href="#_1-6-8-df" class="header-anchor">#</a> 1.6.8 df</h3> <p>报告文件系统磁盘空间的使用情况。</p> <p><code>-T</code> 输出文件类型。</p> <p><code>-h</code> 以最常见的格式显示出大小。</p> <h3 id="_1-6-9-grep"><a href="#_1-6-9-grep" class="header-anchor">#</a> 1.6.9 grep</h3> <p><code>-n</code> 显示行号。</p> <p><code>-v</code> 改变匹配的意义，不显示匹配的行。通常配合使用：</p> <p><code>pa -aux | grep -n xxx | grep -v &quot;grep&quot;</code></p> <h3 id="_1-6-10-file"><a href="#_1-6-10-file" class="header-anchor">#</a> 1.6.10 file</h3> <p>查看文件类型。</p> <h3 id="_1-6-11-time"><a href="#_1-6-11-time" class="header-anchor">#</a> 1.6.11 time</h3> <p>多次执行一个脚本。</p> <p><code>time &lt;可执行文件&gt; [次数]</code></p> <p>输出每次重复操作(iteration)所需时间的平均值，以微秒为单位。测量时间使用流(elapsed)时间，而不是 CPU 时间。</p> <h3 id="_1-6-12-ls"><a href="#_1-6-12-ls" class="header-anchor">#</a> 1.6.12 ls</h3> <p>列出目录内容。</p> <p><code>-F</code> 目录显示 <code>/</code> 后缀。</p> <p><code>-l</code> 显示文件详细信息</p> <p><code>-a</code> 显示所有隐藏文件</p> <p><code>R</code> 递归显示子目录所有内容。</p> <p><code>i</code> 显示 <code>inode</code>。</p> <p><code>-h</code> 以最常见的格式显示出大小。</p> <p><code>-d</code> 查看目录自己的内容，而不是目录下的内容。</p> <p><code>ls -alrF</code>。</p> <h3 id="_1-6-13-tar"><a href="#_1-6-13-tar" class="header-anchor">#</a> 1.6.13 tar</h3> <p>7z 和 zip 压缩格式都不能保留 unix 风格的文件权限，比如解压出个可执行文件要重新 chmod chown 才能恢复正常。而 tar 格式可以。而 tar 本身不提供压缩，无非就是把包括所有文件的內容和权限拼成一个文件而己，所以用另外如 gzip 格式压缩。</p> <p>存储或提取 tar 文件的程序。</p> <p><code>-f</code> 指定存档或设备中的文件。</p> <p><code>-z</code> 用 <code>gzip</code> 处理文档。</p> <p><code>-x</code> 从文档提取文件。</p> <p><code>-c</code> 创建一个新的文档。</p> <p><code>-v</code> 显示文件处理过程。</p> <p><code>tar -xzvf</code> 解压 <code>tar.gz</code> 文件。</p> <p><code>tar -czvf</code> 压缩为 <code>tar.gz</code> 文件。</p> <p>xz 压缩效果最好，多线程压缩最快。</p> <p><code>tar -cvf &lt;压缩目标&gt; | xz -T 0 -c &gt; &lt;压缩包名&gt;.tar.xz</code> 或 <code>tar -I &quot;xz -T0&quot; -cvf &lt;压缩包名&gt;.tar.xz &lt;压缩目标&gt;</code></p> <h3 id="_1-6-14-chmod"><a href="#_1-6-14-chmod" class="header-anchor">#</a> 1.6.14 chmod</h3> <p>改变文件或目录的访问权限。</p> <h3 id="_1-6-15-chgrp"><a href="#_1-6-15-chgrp" class="header-anchor">#</a> 1.6.15 chgrp</h3> <p>改变文件或目录所属的组。</p> <h3 id="_1-6-16-ln"><a href="#_1-6-16-ln" class="header-anchor">#</a> 1.6.16 ln</h3> <p>在文件之间建立连接。</p> <p>默认建立硬链接。</p> <p><code>-s</code> 建立软链接。</p> <p>Linux 下的文件是通过索引节点（Inode）来识别文件，在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (Inode Number)。</p> <p>在 Linux 中，多个文件名指向同一索引节点是存在的，所以硬连接指通过索引节点来进行的连接，即每一个硬链接都是一个指向对应区域的文件。</p> <p>文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</p> <p>不能对目录创建硬链接。</p> <p><strong>硬链接的作用是允许一个文件拥有多个有效路径名</strong>，这样用户就可以建立硬链接到重要文件,有防止“误删”的功能。</p> <p>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个链接被删除后，文件的数据块及目录的连接才会被释放，也就是说，文件才会被真正删除。</p> <p><strong>软链接和源文件是两个不同的文件</strong>，支持跨文件系统建立。</p> <h3 id="_1-6-17-whereis"><a href="#_1-6-17-whereis" class="header-anchor">#</a> 1.6.17 whereis</h3> <p>查命令、源文件和man文件。</p> <p>locate the binary, source, and manual page files for a command。</p> <p><code>-b</code> 只搜索二进制。</p> <h3 id="_1-6-18-mkdir"><a href="#_1-6-18-mkdir" class="header-anchor">#</a> 1.6.18 mkdir</h3> <p><code>-p</code> 嵌套创建子目录。</p> <h3 id="_1-6-19-ps"><a href="#_1-6-19-ps" class="header-anchor">#</a> 1.6.19 ps</h3> <p>列出当前进程。</p> <p><code>-l</code> 查看当前终端的进程</p> <p><code>-ef</code> 以标准语法查看进程。</p> <p><code>-aux</code> 使用 BSD 语法查看进程。</p> <p><code>-le</code></p> <p><code>-axj</code> 查看所有守护进程</p> <p>其中：</p> <ul><li><code>USER</code> 进程的启动者</li> <li><code>PID</code> 进程 ID</li> <li><code>%CPU</code> CPU 占用百分比</li> <li><code>%MEM</code> 内存占用百分比</li> <li><code>VSZ</code> 占用虚拟内存（swap空间）的大小</li> <li><code>RSS</code> 占用常驻内存（物理内存）的大小</li> <li><code>TTY</code> teel to you，终端，? 表示不需要终端或未知终端</li> <li><code>STAT</code> 进程状态：
<ul><li><code>D</code> 无法中断的休眠状态</li> <li><code>S</code> 休眠 sleep</li> <li><code>R</code> 运行</li> <li><code>Z</code> zombie ，僵死</li> <li><code>&lt;</code> 高优先级</li> <li><code>N</code> 低优先级</li> <li><code>s</code> 父进程</li> <li><code>+</code> 前台进程</li> <li><code>X</code> 死掉的进程</li> <li><code>L</code> 有些页被缩进内存</li> <li><code>l</code> 多线程，克隆线程。</li> <li><code>T</code> 停止或被追踪。</li></ul></li> <li><code>START</code> 启动改进程的时间</li> <li><code>TIME</code> 该进程占用 CPU 时间</li> <li><code>COMMAND</code> 启动该进程的命令的名称</li></ul> <h3 id="_1-6-20-kill"><a href="#_1-6-20-kill" class="header-anchor">#</a> 1.6.20 kill</h3> <p><code>kill [-signal] PID</code></p> <p>给指定进程发送指定信号. 如果没有指定信号, 则发送 TERM信号.  TERM 信号会杀死不能俘获该信号的进程.  对于其他进程,可能需要使用 KILL (9) 信号, 因为该信号不能够被俘获.</p> <p><code>SIGHUP</code> 1 终端在结束时，会给其下所有进程发送某个信号。对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</p> <p><code>SIGINT</code> 2 结束进程 <code>C-C</code></p> <p><code>SIGQUIT</code> 3 结束进程 <code>C-\</code></p> <p><code>SIGUSR1</code> 10 自定义</p> <p><code>SIGUSR2</code> 12 自定义</p> <p><code>SIGKILL</code> 9 杀死进程信号，不能不捕捉，不能被忽略、阻塞、注册。</p> <p><code>SIGALRM</code> 14 闹钟信号，定时器，当倒计时进程结束，结束进程</p> <p><code>SIGTERM</code> 15 终止信号。</p> <p><code>SIGHLD</code> 17 子进程结束，给父进程发送的信号</p> <p><code>SIGSTOP</code> 19 暂停进程，不能被捕捉信号，不能被忽略，不能被阻塞。</p> <p><code>SIGTSTP</code> 20 暂停进程，<code>C-Z</code></p> <h3 id="_1-6-21-chown"><a href="#_1-6-21-chown" class="header-anchor">#</a> 1.6.21 chown</h3> <p>修改文件所有者和组别。</p> <h3 id="_1-6-22-sync"><a href="#_1-6-22-sync" class="header-anchor">#</a> 1.6.22 sync</h3> <p>将内存的数据写回硬盘，并释放缓存。
Linux系统运行过程中，会有大量的临时数据驻留在内存缓存区，在关闭系统时需要将内存数据与硬盘数据进行同步校验，以保证系统数据不丢失。因此，通常sync命令是在关闭Linux系统前时使用。</p> <h3 id="_1-6-23-adduser"><a href="#_1-6-23-adduser" class="header-anchor">#</a> 1.6.23 adduser</h3> <p>添加用户。</p> <p>deluser 删除用户的同时删除用户的工作目录。</p> <p>delgroup 删除用户组。</p> <p><code>/etc/shadow</code>文件是加密的用户清单。</p> <p><code>/etc/passwd</code>文件是系统能够识别的用户清单。</p> <p><code>/etc/group</code> 文件包含了UNIX组的名称和每个组中成员列表。</p> <h3 id="_1-6-24-locate"><a href="#_1-6-24-locate" class="header-anchor">#</a> 1.6.24 locate</h3> <p>超快速查找任意文件。</p> <p>查找速度最快，但需要更新数据库。</p> <p><code>$ sudo updatedb</code></p> <p><code>-r</code> 使用正则表达式，如 <code>locate -r '\bls$'</code></p> <h3 id="_1-6-25-find"><a href="#_1-6-25-find" class="header-anchor">#</a> 1.6.25 find</h3> <p>功能最强大，但速度慢。</p> <h3 id="_1-6-26-grep"><a href="#_1-6-26-grep" class="header-anchor">#</a> 1.6.26 grep</h3> <p>打印匹配给定模式的行。</p> <p><code>grep [options] PATTERN [FILE]</code></p> <p>如 <code>grep enum /usr/include/*</code></p> <h3 id="_1-6-27-size"><a href="#_1-6-27-size" class="header-anchor">#</a> 1.6.27 size</h3> <p>指定输入文件各段及其总和的大小。（可执行文件、静态库、动态库、目标文件）</p> <h3 id="_1-6-28-strace"><a href="#_1-6-28-strace" class="header-anchor">#</a> 1.6.28 strace</h3> <p>跟踪可执行程序的系统调用。</p> <p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p> <p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。</p> <p>strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p> <h3 id="_1-6-29-nm"><a href="#_1-6-29-nm" class="header-anchor">#</a> 1.6.29 nm</h3> <p>nm 是name 的缩写，它显示指定文件中的符号信息，文件可以是对象文件、可执行文件或对象文件库。如果文件中没有包含符号信息，nm报告该情况，单不把他解释为出错。nm缺省情况下报告十进制符号表示法下的数字值。</p> <p><code>nm -C xxx.o</code></p> <h3 id="_1-6-30-umask"><a href="#_1-6-30-umask" class="header-anchor">#</a> 1.6.30 umask</h3> <p>Linux 不同，它是通过使用 umask 默认权限来给所有新建的文件和目录赋予初始权限的。</p> <p>root用户默认是0022，普通用户默认是 0002</p> <p>文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限</p> <p>umask -S 查看默认权限</p> <p>默认权限：文件 0777 - 0002 = 0755
目录 0666 - 0002 = 0644</p> <h3 id="_1-6-31-ldd"><a href="#_1-6-31-ldd" class="header-anchor">#</a> 1.6.31 ldd</h3> <p>命令可以查看一个可执行程序依赖的共享库。</p> <h3 id="_1-6-32-fg-bg-jobs"><a href="#_1-6-32-fg-bg-jobs" class="header-anchor">#</a> 1.6.32 fg,bg,jobs</h3> <p><code>jobs -l</code> 命令可以用来查看当前终端放入后台的工作</p> <p><code>fg %num</code> 命令用于把后台工作恢复到前台执行</p> <p><code>bg %num</code> 把后台暂停的工作恢复到后台执行</p> <h3 id="_1-6-33-nohub"><a href="#_1-6-33-nohub" class="header-anchor">#</a> 1.6.33 nohub,&amp;</h3> <p>nohup 不挂断地运行命令。no hangup的缩写，意即“不挂断”。命令的作用就是让后台工作在离开操作终端时，也能够正确地在后台执行。</p> <p>nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。</p> <p><code>nohup COMMAND &amp;</code> 这样就能使命令永久的在后台执行。</p> <h2 id="_1-7-elf-文件"><a href="#_1-7-elf-文件" class="header-anchor">#</a> 1.7 ELF 文件</h2> <p>ELF文件是一种用于二进制文件、可执行文件、目标代码、共享库和core转存格式文件。是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。</p> <p>elf 文件头，内部分段</p> <p>有三类文件属于 ELF 格式，</p> <ol><li>可执行文件</li> <li>目标文件。</li></ol> <p><code>readelf -a</code> 查看 <code>elf</code> 文件。</p> <p>1）可重定位文件（Relocatable File）</p> <p>包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据，即 xxx.o 文件。</p> <p>2）可执行文件（Executable File）</p> <p>包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像，即 a.out文件。</p> <p>3）共享目标文件（Shared Object File）</p> <p>包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像，即 xxx.so文件。</p> <p>4）内核转储(core dumps)</p> <p>存放当前进程的执行上下文，用于dump信号触发。</p> <p><img src="/linux/ELF%E6%A0%BC%E5%BC%8F.jpg" alt=""></p> <p><img src="/linux/ELF%E8%A7%86%E5%9B%BE.jpg" alt=""></p> <p>ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。</p> <p><code>objdump -D</code> 查看反汇编信息。</p> <p><code>objdump -S</code> 查看目标的汇编代码。</p> <h2 id="_1-8-常见服务"><a href="#_1-8-常见服务" class="header-anchor">#</a> 1.8 常见服务</h2> <p><code>/etc/init.d/ssh restart</code> 重启 <code>ssh</code> 服务。</p> <p><code>service sshd restart</code></p> <p><code>systemctl status tftpd-hpa</code> 查看服务状态。</p> <p><code>service tftpd-hpa status</code></p> <p><code>sshd</code> 服务，远程访问虚拟机服务。</p> <p><code>Samba</code> 服务，linux 和 windows 共享目录</p> <p><code>tftp</code> 服务，提供内核镜像 zImage 供 uboot 下载。</p> <p><code>nfs</code> 服务，提供网络文件系统。</p> <h2 id="_1-9-进程"><a href="#_1-9-进程" class="header-anchor">#</a> 1.9 进程</h2> <h3 id="_1-9-1-进程的组成"><a href="#_1-9-1-进程的组成" class="header-anchor">#</a> 1.9.1 进程的组成</h3> <p>每个进程都有自己的 PCB，所有进程都有唯一的 PCB。操作系统依据PCB管理进程，操作系统利用PCB实现进程的动态和并发，PCB是进程存在的唯一标志。</p> <p>所有进程都是既运行于用户方式下，又运行于系统方式下。进程每次调用一个系统调用时，都要从用户方式切换到系统方式，并继续执行。</p> <p>进程的状态：</p> <table><thead><tr><th>标志</th> <th>状态</th></tr></thead> <tbody><tr><td><code>D</code></td> <td>不可中断的静止</td></tr> <tr><td><code>R</code></td> <td>正在执行中</td></tr> <tr><td><code>S</code></td> <td>阻塞状态</td></tr> <tr><td><code>T</code></td> <td>暂停执行</td></tr> <tr><td><code>Z</code></td> <td>不存在但是暂时无法消除</td></tr> <tr><td><code>W</code></td> <td>没有足够的内存分页可以分配</td></tr> <tr><td><code>&lt;</code></td> <td>高优先级的进程</td></tr> <tr><td><code>N</code></td> <td>低优先级的进程</td></tr> <tr><td><code>L</code></td> <td>有内存分页分配并所在内存中</td></tr></tbody></table> <p><code>c-z</code> 暂停进程。</p> <p><code>c-c</code> 停止进程，可以被捕获。</p> <p><code>jobs -l</code> 查看后台进程。</p> <p><code>fg %num</code> 把后台进程调到前台。</p> <p><code>&amp;</code> 让进程在后台执行。</p> <h3 id="_1-9-2-linux-系统中的进程类型"><a href="#_1-9-2-linux-系统中的进程类型" class="header-anchor">#</a> 1.9.2 Linux 系统中的进程类型</h3> <p>（1）交互教程</p> <p>（2）批处理进程</p> <p>（3）守护进程</p> <h3 id="_1-9-3-进程的互斥"><a href="#_1-9-3-进程的互斥" class="header-anchor">#</a> 1.9.3 进程的互斥</h3> <p>（1）临界资源</p> <p>操作系统中将以此只允许一个进程访问的资源。</p> <p>（2）进程互斥</p> <p>若干进程要使用某一个共享资源时，任何时候最多允许一个进程使用。任何时候最多允许一个进程使用，其他要使用该资源的进程必须等待，直到只用自愿者释放了该资源。</p> <p>（3）进程同步</p> <p>一组并发进程按一定的顺序执行的过程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间互相发送的信号称为消息或事件。</p> <p>（4）临界区</p> <p>进程中访问连接资源的那段代码称为临界区。为实现对临界资源的互斥访问，应保证诸进程互斥地进入各自的临界区。</p> <h3 id="_1-9-4-进程的调度"><a href="#_1-9-4-进程的调度" class="header-anchor">#</a> 1.9.4 进程的调度</h3> <p>（1）抢占式调度</p> <p>（2）非抢占式调度</p> <p>（3）先来先服务调度算法</p> <p>（4）短进程优先调度算法</p> <p>（5）高优先级优先调度算法</p> <p>（6）时间片轮转法</p> <h3 id="_1-9-5-死锁"><a href="#_1-9-5-死锁" class="header-anchor">#</a> 1.9.5 死锁</h3> <p>多个进程因竞争资源而形成一种僵局，若无外力作用，这些进程将永远不能向前推进。</p> <ul><li>互斥条件，临界资源是独占资源，进程应互斥且排他的使用这些资源。</li> <li>占有和等待条件，进程在请求资源得不到满足而等待时，不释放已占有资源。</li> <li>不剥夺条件，又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</li> <li>循环等待条件，又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li></ul> <p>各种死锁防止方法能够防止发生死锁，但必然会降低系统并发性，导致低效的资源利用率。</p> <p>避免死锁：银行家算法</p> <p>死锁检测和解除</p> <h3 id="_1-9-6-进程的模式"><a href="#_1-9-6-进程的模式" class="header-anchor">#</a> 1.9.6 进程的模式</h3> <p>进程的执行模式分为用户模式和内核模式。</p> <p>用户模式通过系统调用进入系统调用。</p> <h3 id="_1-9-7-进程的创建"><a href="#_1-9-7-进程的创建" class="header-anchor">#</a> 1.9.7 进程的创建</h3> <p>函数原型：<code>pid_t fork(void);</code></p> <p>fork确实创建可一个子进程并完全复制父进程，但是子进程是从fork后面的那个指令开始执行。</p> <p>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。</p> <p>父子进程间共享的存储空间只有代码段。</p> <p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p> <ul><li>在父进程中，fork返回新创建子进程的进程ID；</li> <li>在子进程中，fork返回 0。
如果出现错误，fork返回一个负值。</li></ul> <p>fork 的执行过程：</p> <ul><li>申请PID</li> <li>申请PCB结构</li> <li>复制父进程的PCB</li> <li>将子进程的运行状态设置为不可执行的</li> <li>将子进程中的某些属性清零，某些保留，某些修改</li> <li>复制父进程的页（用到了写时拷贝技术）</li></ul> <p>写时拷贝技术： 父子进程在初始阶段共享所有的数据（全局、 栈区、 堆区、 代码）， 内核会将所有的区域设置为只读。 当父子进程中任意一个进程试图修改其中的数据时， 内核才会将要修改的数据所在的区域（页） 拷贝一份。</p> <h2 id="_1-10-linux-下的进程管理"><a href="#_1-10-linux-下的进程管理" class="header-anchor">#</a> 1.10 Linux 下的进程管理</h2> <p>（1）启动进程</p> <ul><li>手工启动（<code>bg</code>后台运行，<code>fg</code>前台运行）</li> <li>调度启动（<code>at</code>在指定时刻执行相关进程，<code>corn</code>周期性执行相关进程）</li></ul> <p>TODO: 进程组、会话</p> <h2 id="_1-11-内核空间和用户空间"><a href="#_1-11-内核空间和用户空间" class="header-anchor">#</a> 1.11 内核空间和用户空间</h2> <p>以32 位 Linux 操作系统为例，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p> <p>用户态的程序不能随意操作内核地址空间，这样对操作系统具有一定的安全保护作用。</p> <p>当进程/线程运行在内核空间时就处于内核态，而进程/线程运行在用户空间时则处于用户态。</p> <p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态），除了系统调用可以实现用户态到内核态的切换，还有软中断和硬中断。软中断是指进程发生了异常事件；硬中断就有很多种，例如时钟周期、IO等。</p> <p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</p> <p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的很多检查，比如：进程只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址。</p> <p><img src="/linux/linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" alt=""></p> <h2 id="_1-12-命令置换"><a href="#_1-12-命令置换" class="header-anchor">#</a> 1.12 命令置换</h2> <p>将一个命令的输出作为另一个命令的参数。</p> <p>格式如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>command1 `command2`

如:
$ ls `pwd`

将 pwd 命令的结果作为 ls 命令的参数。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_1-13-exec-函数族"><a href="#_1-13-exec-函数族" class="header-anchor">#</a> 1.13 exec 函数族</h2> <p>exec函数族提供了一种在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，</p> <p>并用它来取代原调用进程的数据段、代码段和堆栈段。在执行完之后，原调用进程的内容除了进程号外，其他全部都被替换了。</p> <p>可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。</p> <p>当进程调用exec函数时，该进程被完全替换为新程序。因为调用exec函数并不创建新进程，所以前后进程的ID并没有改变。</p> <p>exec 函数族提供了六种在进程中启动另一个程序的方法。exec 函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容。</p> <h3 id="_1-13-1-使用场景"><a href="#_1-13-1-使用场景" class="header-anchor">#</a> 1.13.1 使用场景</h3> <p>当进程认为自己不能再为系统和用户做出任何贡献了时就可以调用exec函数，让自己执行新的程序</p> <p>如果某个进程想同时执行另一个程序，它就可以调用fork函数创建子进程，然后在子进程中调用任何一个exec函数。这样看起来就好像通过执行应用程序而产生了一个新进程一样</p> <h3 id="_1-13-2-语法"><a href="#_1-13-2-语法" class="header-anchor">#</a> 1.13.2 语法</h3> <p><strong>函数原型</strong></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>environ<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>execve</code> 是系统调用。</p> <p>l(list)：参数地址列表，以空指针结尾。</p> <p>v(vector)：存有各参数地址的指针数组的地址。</p> <p>p(path)：按 PATH 环境变量指定的目录搜索可执行文件。</p> <p>e(environment)：存有环境变量字符串地址的指针数组的地址。</p> <p><strong>返回值</strong></p> <p>exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。</p> <p><strong>参数说明</strong></p> <ul><li>path：可执行文件的路径名字</li> <li>arg：可执行程序所带的参数，第一个参数为可执行文件名字，没有带路径且arg必须以NULL结束</li> <li>file：如果参数file中包含/，则就将其视为路径名，否则就按 PATH环境变量，在它所指定的各目录中搜寻可执行文件。</li></ul> <p>exec族函数参数极难记忆和分辨，函数名中的字符会给我们一些帮助：</p> <ul><li>l : 使用参数列表</li> <li>p：使用文件名，并从PATH环境进行寻找可执行文件</li> <li>v：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。</li> <li>e：多了envp[]数组，使用新的环境变量代替调用进程的环境变量</li></ul> <p>一、带l的一类exac函数（l表示list），包括execl、execlp、execle，要求将新程序的每个命令行参数都说明为 一个单独的参数。这种参数表以空指针结尾。</p> <p>例：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;before exec\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">/* /bin/ls：外部程序，这里是/bin目录的 ls 可执行程序，必须带上路径（相对或绝对）
	   ls：没有意义，如果需要给这个外部程序传参，这里必须要写上字符串，至于字符串内容任意
	   -a，-l，-h：给外部程序 ls 传的参数
	   NULL：这个必须写上，代表给外部程序 ls 传参结束
	*/</span>
	<span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-l&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-h&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 如果 execl() 执行成功，下面执行不到，因为当前进程已经被执行的 ls 替换了</span>
	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;execl&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;after exec\n\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>二、带p的一类exac函数，包括execlp、execvp、execvpe，如果参数file中包含/，则就将其视为路径名，否则就按 PATH环境变量，</p> <p>在它所指定的各目录中搜寻可执行文件。举个例子，<code>PATH=/bin:/usr/bin</code></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">//文件execlp.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment">// 第一个参数 &quot;ls&quot;，没有带路径名，在环境变量 PATH 里寻找这个可执行程序</span>
 <span class="token comment">// 其它参数用法和 execl() 一样</span>
	<span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-l&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-h&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">/*
	char *arg[]={&quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL};
	execvp(&quot;ls&quot;, arg);
	*/</span>

	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;execlp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>三、带v不带l的一类exac函数，包括execv、execvp、execve，应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。</p> <p>如 <code>char *arg[]</code> 这种形式，且arg最后一个元素必须是NULL，例如 <code>char *arg[] = {“ls”,”-l”,NULL}</code>;</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment">// execv() 和 execl() 的用法基本是一样的，无非将列表传参，改为用指针数组</span>
 <span class="token comment">// execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL);</span>

 <span class="token comment">/* 指针数组
	   ls：没有意义，如果需要给这个外部程序传参，这里必须要写上字符串，至于字符串内容任意
	   -a，-l，-h：给外部程序 ls 传的参数
	   NULL：这个必须写上，代表给外部程序 ls 传参结束
	*/</span>
 <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-l&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-h&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token comment">// /bin/ls：外部程序，这里是/bin目录的 ls 可执行程序，必须带上路径（相对或绝对）</span>
 <span class="token comment">// arg： 上面定义的指针数组地址</span>
	<span class="token function">execv</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/ls&quot;</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;execv&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment">// 第一个参数 &quot;ls&quot;，没有带路径名，在环境变量 PATH 里寻找这个可执行程序</span>
 <span class="token comment">// 其它参数用法和 execl() 一样</span>
	<span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-l&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-h&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">/*
	char *arg[]={&quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL};
	execvp(&quot;ls&quot;, arg);
	*/</span>

	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;execlp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>四、带e的一类exac函数，包括execle、execvpe，可以传递一个指向环境字符串指针数组的指针。</p> <p>参数例如 <code>char *env_init[] = {“AA=aa”,”BB=bb”,NULL}</code>; 带e表示该函数取envp[]数组，而不使用当前环境。</p> <p>execle() 和 execve() 改变的是 exec 启动的程序的环境变量（只会改变进程的环境变量，不会影响系统的环境变量）</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// exec.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span> <span class="token comment">// getenv()</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment">// getenv() 获取指定环境变量的值</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;before exec：USER=%s, HOME=%s\n&quot;</span><span class="token punctuation">,</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">&quot;USER&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">&quot;HOME&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 指针数据</span>
 <span class="token keyword">char</span> <span class="token operator">*</span>env<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&quot;USER=MIKE&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;HOME=/tmp&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token comment">/* ./mike：外部程序，当前路径的 mike 程序，通过 gcc mike.c -o mike 编译
		mike：这里没有意义
		NULL：给 mike 程序传参结束
		env：改变 mike 程序的环境变量，正确来说，让 mike 程序只保留 env 的环境变量
	 */</span>
	<span class="token function">execle</span><span class="token punctuation">(</span><span class="token string">&quot;./mike&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mike&quot;</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">/*
	char *arg[]={&quot;mike&quot;, NULL};
	execve(&quot;./mike&quot;, arg, env);
	*/</span>

	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;execle&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 外部程序 mike.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\nin the mike fun, after exec: \n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;USER=%s\n&quot;</span><span class="token punctuation">,</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">&quot;USER&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;HOME=%s\n&quot;</span><span class="token punctuation">,</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">&quot;HOME&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><h2 id="_1-14-ext4-文件系统"><a href="#_1-14-ext4-文件系统" class="header-anchor">#</a> 1.14 ext4 文件系统</h2> <p>TODO:</p> <h2 id="_1-15-文件锁"><a href="#_1-15-文件锁" class="header-anchor">#</a> 1.15 文件锁</h2> <h3 id="_1-15-1-对整个文件锁定"><a href="#_1-15-1-对整个文件锁定" class="header-anchor">#</a> 1.15.1 对整个文件锁定</h3> <p>flock - apply or remove an advisory lock on an open file</p> <p><code>int flock(int fd, int operation);</code></p> <p>id 是需要加锁的文件的描述符，operation 可以是下列值：</p> <ul><li><code>LOCK_SH</code> 共享锁，多个进程可以同时拥有对文件的共享锁。</li> <li><code>LOCK_EX</code> 互斥锁，一个文件只能上一把互斥锁。</li> <li><code>LOCK_UN</code> 解锁操作。</li> <li><code>LOCK_NB</code> 如果进程不能获取指定的锁，函数将不阻塞，缺省时，进程将睡眠等待。</li></ul> <p>共享锁用于不更改或不更新数据的操作（只读操作）</p> <h2 id="_1-16-进程的结束"><a href="#_1-16-进程的结束" class="header-anchor">#</a> 1.16 进程的结束</h2> <h3 id="_1-16-1-exit-和-exit"><a href="#_1-16-1-exit-和-exit" class="header-anchor">#</a> 1.16.1 exit 和 _exit</h3> <p><code>void exit(int status);</code></p> <p><code>void _exit(int status)</code></p> <p>status 是一个整型的参数，可以利用这个参数传递进程结束时的状态。通常用 0 表示正常结束，其他数值表示出现了错误，进程非正常结束。</p> <p>再实际编程时，可以用 wait 系统调用接受子进程的返回值，进行相应的处理。</p> <p><code>_exit()</code> 函数作用最简单，直接使进程终止运行，清除使用的内存空间，并销毁数据结构。</p> <p><code>exit()</code> 函数则在这些基础上作了一些包装，推出前检查文件的打开情况，把文件缓冲区中的内容写回文件，清理 I/O 缓冲。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Using exit...\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;This is the end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span>root@farsight<span class="token punctuation">]</span># <span class="token punctuation">.</span><span class="token operator">/</span>exit_test2
Using exit<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> This is the end
<span class="token punctuation">[</span>root@farsight<span class="token punctuation">]</span>#

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Using _exit...\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;This is the end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token punctuation">[</span>root@farsight<span class="token punctuation">]</span># <span class="token punctuation">.</span><span class="token operator">/</span>_exit
Using _exit<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span>root@farsight<span class="token punctuation">]</span>#
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="_1-16-2-wait-waitpid"><a href="#_1-16-2-wait-waitpid" class="header-anchor">#</a> 1.16.2 wait/waitpid</h3> <p><strong>（1）wait函数</strong></p> <p>调用该函数使进程阻塞，直到任一个子进程结束或者是该进程接收到了一个信号为止。如果该进程没有子进程或者其子进程已经结束，wait函数会立即返回。</p> <p>waitpid函数</p> <p>功能和wait函数类似。可以指定等待某个子进程结束以及等待的方式（阻塞或非阻塞）</p> <p>头文件</p> <p><code>#include &lt;sys/types.h&gt;</code> <code>#include &lt;sys/wait.h&gt;</code></p> <p>函数原型： <code>pid_t wait(int *status)</code></p> <p>参数：</p> <p>status 是一个整型指针，指向的对象用来保存子进程推出时的状态。</p> <ul><li>status 若为空，则表示忽略子进程退出时的状态。</li> <li>status 不为空，则表示保存子进程退出时的所有状态。</li></ul> <p>此为可以用一些宏检测：</p> <table><thead><tr><th style="text-align:center;">状态</th> <th style="text-align:center;">判断宏</th> <th style="text-align:center;">取值宏</th></tr></thead> <tbody><tr><td style="text-align:center;">进程正常结束</td> <td style="text-align:center;"><code>WIFEXITED(status)</code></td> <td style="text-align:center;"><code>WEXITSTATUS(status)</code></td></tr> <tr><td style="text-align:center;">进程正常结束</td> <td style="text-align:center;"><code>WIFSIGNALED(status)</code></td> <td style="text-align:center;"><code>WTERMSIG(status)</code></td></tr> <tr><td style="text-align:center;">进程正常结束</td> <td style="text-align:center;"><code>WIFSTOPPED(status)</code></td> <td style="text-align:center;"><code>WSTOPSIG(status)</code></td></tr></tbody></table> <p>WTERMSIG宏测试被执行后，若成功返回被终止的子进程的信号值。返回的信号值被定义在 sys/signals.h头文件中。</p> <p>返回值：成功返回结束子进程的 pid 码。</p> <p><strong>（2）waitpid 函数</strong></p> <p>一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程(Zombie)的数据结构</p> <p>(系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁)。</p> <p>函数原型：<code>pid_t waitpid(pid_t pid, int *status, int options);</code></p> <p>函数参数：</p> <ul><li><code>pid</code> <ul><li><code>&gt;0</code> 只等待进程 ID 等于 pid 的子进程，只要指定的子进程还没有结束，waitpid 就会一直等下去。</li> <li><code>=-1</code>，等待任何一个子进程退出，和 <code>wait</code> 作用一样。</li> <li><code>=0</code> 等待组 ID 等于调用进程的组 ID 的任一子进程。</li> <li><code>&lt; -1</code> 等待其组 ID 等于 pid 的绝对值的任一子进程。</li></ul></li> <li><code>status</code> ，同 wait</li> <li><code>options</code> <ul><li><code>WNOHANG</code> 若由 pid 指定的子进程并不立即可用，则 waitpid 不阻塞，此时返回值为 0。</li> <li><code>WUNTRACED</code> 若某实现支持作业控制，则由 pid 指定的任意子进程状态已暂停，且其状态子暂停依赖还未报告过，则返回其状态。</li> <li><code>0</code> 阻塞父进程，等待子进程退出。</li> <li>判断子进程结束原因
<ul><li><code>WIFEXITED</code></li> <li><code>WIFSIGNALED</code></li> <li><code>WIFSTOPPED</code></li> <li><code>WSTOPSIG</code></li></ul></li></ul></li></ul> <p>进程组组号，等于父进程 pid</p> <p>函数返回值：</p> <ul><li>正常：结束的子进程的进程号。</li> <li>使用选项 WNOHANG 且没有子进程结束时：0</li> <li>调用出错 -1，设置错误码</li></ul> <h2 id="_1-17-守护进程"><a href="#_1-17-守护进程" class="header-anchor">#</a> 1.17 守护进程</h2> <h3 id="_1-17-1-守护进程和后台进程的区别"><a href="#_1-17-1-守护进程和后台进程的区别" class="header-anchor">#</a> 1.17.1 守护进程和后台进程的区别</h3> <p><strong>守护进程与后台进程的区别</strong></p> <ul><li>守护进程已经完全脱离终端控制台了，而后台程序并未完全脱离终端，在终端未关闭前还是会往终端输出结果</li> <li>守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在以 <code>nohup command &amp;</code> 格式运行才能避免影响</li></ul> <p><strong>实现守护进程的方式</strong></p> <p>要实现守护进程，一种方法是按守护进程的规则去编程，比较麻烦；另一种方法是仍然用普通方法编程，然后用nohup命令启动程序：</p> <p><code>nohup &lt;程序名&gt; &amp;</code></p> <p>用nohup启动的进程，当控制台logout后，进程仍然继续运行，起到守护进程的作用（虽然它不是严格意义上的守护进程）。</p> <p>默认情况下，使用nohup命令后，原程序的的标准输出被自动改向到当前目录下的nohup.out文件，起到了log的作用，实现了完整的守护进程功能。</p> <p><strong>为什么脱离终端？</strong></p> <p>守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？
之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，
其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，
每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，
这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p> <h3 id="_1-17-2-介绍"><a href="#_1-17-2-介绍" class="header-anchor">#</a> 1.17.2 介绍</h3> <p>Daemon 进程，生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</p> <p>守护进程常常在系统引导装入时启动，在系统关闭时终止。</p> <p>在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会被自动关闭。</p> <p>守护进程能够突破这种限制，它从被执行开始运转，直到整个系统关闭才会退出。如果想让某个进程不因为<strong>用户或终端</strong>或其他的变化而受到影响，就必须把这个进程变成一个守护进程。</p> <p><strong>守护进程的一些特点</strong></p> <ul><li>守护进程基本上都是以超级用户启动（ UID 为 0 ）</li> <li>没有控制终端（ TTY 为 ？）</li> <li>终端进程组 ID 为 -1 （ TPGID 表示终端进程组 ID）</li></ul> <p>一般情况下，守护进程可以通过以下方式启动：</p> <ul><li>在系统启动时由启动脚本启动，这些启动脚本通常放在 /etc/rc.d 目录下；</li> <li>利用 inetd 超级服务器启动，如 telnet 等；</li> <li>由 cron 定时启动以及在终端用 nohup 启动的进程也是守护进程。</li></ul> <h3 id="_1-17-3-进程组和会话期"><a href="#_1-17-3-进程组和会话期" class="header-anchor">#</a> 1.17.3 进程组和会话期</h3> <p><strong>（1）进程组</strong></p> <p>进程组是一个或多个进程的集合。进程组由进程组 ID 来唯一标识，除了进程号（PID）之外，进程组 ID 也是一个进程的必备属性之一。</p> <p>每个进程组都有一个组长进程，<strong>组长进程的进程号</strong>等于进程组 ID。</p> <p><strong>（2）会话期</strong></p> <p>会话组是一个或多个进程组的集合。</p> <p>通常一个会话开始于用户登录，种植于用户退出，在此期间该用户运行的所有进程都属于这个会话期。</p> <p><strong>（3）setsid()</strong></p> <p><code>setsid()</code> 创建一个新会话，并担任该会话组的组长，调用setsid函数的目的：让进程摆脱原会话，原进程组，原终端的控制。如果，<strong>调用setsid的进程不是一个进程组的组长</strong>，此函数创建一个新的会话期。</p> <p>setsid 的调用者不能是 group leader。</p> <ul><li>摆脱原会话的控制。</li> <li>摆脱原进程组的控制。</li> <li>摆脱原控制终端的控制。</li></ul> <h3 id="_1-17-4-步骤"><a href="#_1-17-4-步骤" class="header-anchor">#</a> 1.17.4 步骤</h3> <p><strong>（1）创建子进程，结束父进程</strong></p> <p>子进程变成孤儿进程，变成 init 进程的子进程。形式上脱离终端控制，在后台工作。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 父进程退出</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>（2）setsid，子进程成为新会话过程的leader 进程</strong></p> <p>子进程全盘拷贝了父进程的会话期、进程组、控制终端，父进程退出了，但会话期、进程组、控制终端没有改变。</p> <p>子进程继续运行，父进程退出的时候，将会产生 SIGHUP 信号。</p> <p>setsid() 调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>现在 sid == pid == pgid，现在收不到终端的信号。</p> <p><strong>（3）进程重新打开控制终端</strong></p> <p>现在进程成为无终端的会话组长，但是如果再打开一个终端，将会成为它的控制终端。</p> <p>因为进程打开一个控制终端的前台条件是该进程必须是会话组长。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 父进程退出</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>结束子进程，第二子进程不再是会话组长。pid != sid，无法打开新的控制终端。</p> <p><strong>（4）关闭打开的文件描述符</strong></p> <p>进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">sysconf</span><span class="token punctuation">(</span>_SC_OPEN_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">close</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>（5）更改工作目录</strong></p> <p>当进程产生错误的时候，将错误信息记录在当前目录的core文件，守护进程的特点一般会一直会打开当前目录。 解决方法，找一个不可能被卸载的目录。</p> <p>使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行过程中，当前目录所在的文件系统是不能卸载的，这对以后的使用会造成诸多的麻烦(比如进入单用户模式)。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>（6）消除 umask 的影响</strong></p> <p>进程从创建它的父进程那里继承了文件创建掩码。它可能修改守护进程所创建的文件的存取权限。为防止这一点，将文件创建掩码清除：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>（7）重新定位 I/O 描述符</strong></p> <p>将标准输入、标准输出、标准错误重定向到 <code>/dev/null</code>。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;/dev/null&quot;</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_1-18-进程和线程的选择与区别"><a href="#_1-18-进程和线程的选择与区别" class="header-anchor">#</a> 1.18 进程和线程的选择与区别</h2> <p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p> <table><thead><tr><th style="text-align:center;">对比维度</th> <th style="text-align:center;">多进程</th> <th style="text-align:center;">多线程</th> <th style="text-align:center;">总结</th></tr></thead> <tbody><tr><td style="text-align:center;">数据共享、同步</td> <td style="text-align:center;">数据共享复杂，需要用 IPC，数据是分开的，同步简单</td> <td style="text-align:center;">共享进程数据，数据共享简单，但是同步复杂</td> <td style="text-align:center;">各有优势</td></tr> <tr><td style="text-align:center;">内存、CPU</td> <td style="text-align:center;">占用内存多，切换复杂，CPU利用率低</td> <td style="text-align:center;">占用内存少，切换简单，CPU利用率高</td> <td style="text-align:center;">线程占优</td></tr> <tr><td style="text-align:center;">创建销毁、切换</td> <td style="text-align:center;">创建销毁、切换复杂、速度慢</td> <td style="text-align:center;">创建销毁、切换简单，速度很快</td> <td style="text-align:center;">线程占优</td></tr> <tr><td style="text-align:center;">编程、调试</td> <td style="text-align:center;">编程简单，调试简单</td> <td style="text-align:center;">编程复杂，调试复杂</td> <td style="text-align:center;">进程占优</td></tr> <tr><td style="text-align:center;">可靠性</td> <td style="text-align:center;">进程间不会互相影响</td> <td style="text-align:center;">一个线程挂掉将会导致整个进程挂掉</td> <td style="text-align:center;">进程占优</td></tr> <tr><td style="text-align:center;">分布式</td> <td style="text-align:center;">适用于多核、多机分布式，扩展多机比较简单</td> <td style="text-align:center;">适用于多核分布式</td> <td style="text-align:center;">进程占优</td></tr></tbody></table> <p><strong>（1）需要频繁创建销毁的优先用线程</strong></p> <p>如 Web 服务器，来一个连接建立一个线程，断了就销毁线程。</p> <p><strong>（2）需要进行大量计算的优先用线程</strong></p> <p>如图像处理、算法处理。</p> <p><strong>（3）强相关的处理用线程，弱相关的处理用进程</strong></p> <p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，
而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。
因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p> <h2 id="_1-19-dup-和-dup2"><a href="#_1-19-dup-和-dup2" class="header-anchor">#</a> 1.19 dup() 和 dup2()</h2> <p><strong>dup()</strong></p> <p>函数原型：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>打开一个新的最小文件描述符，指向和 oldfd 同一个文件，共享文件偏移量和文件状态。</p> <p>失败返回 -1。</p> <p><strong>dup2()</strong></p> <p>函数原型：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">dup2</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">,</span> <span class="token keyword">int</span> newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>dup2 把指定的 newfd 也指向 oldfd 指向的文件，也就是说，执行完dup2之后，有newfd和oldfd同时指向同一个文件，共享文件偏移量和文件状态。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">2023/3/16 09:51:04</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/Linux/" class="prev router-link-active">
        Linux 笔记
      </a></span> <span class="next"><a href="/wiki/Linux/linux-collections.html">
        2 Linux 问题集
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.c0bed5a9.js" defer></script><script src="/wiki/assets/js/2.4b7299de.js" defer></script><script src="/wiki/assets/js/8.7988023b.js" defer></script>
  </body>
</html>
