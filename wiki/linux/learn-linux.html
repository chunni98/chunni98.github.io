<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1 Linux 笔记 | CS Wiki</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="shachi 的 CS 知识库">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.89cce7b1.css" as="style"><link rel="preload" href="/wiki/assets/js/app.e46b2869.js" as="script"><link rel="preload" href="/wiki/assets/js/2.4b7299de.js" as="script"><link rel="preload" href="/wiki/assets/js/8.530182c5.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.427a0828.js"><link rel="prefetch" href="/wiki/assets/js/11.ea74e48c.js"><link rel="prefetch" href="/wiki/assets/js/12.e0881912.js"><link rel="prefetch" href="/wiki/assets/js/13.aa6ca98e.js"><link rel="prefetch" href="/wiki/assets/js/14.f8407d7b.js"><link rel="prefetch" href="/wiki/assets/js/15.a2edb745.js"><link rel="prefetch" href="/wiki/assets/js/16.8fc8ab24.js"><link rel="prefetch" href="/wiki/assets/js/17.109dfb9a.js"><link rel="prefetch" href="/wiki/assets/js/18.4e7f588d.js"><link rel="prefetch" href="/wiki/assets/js/19.8d2496ab.js"><link rel="prefetch" href="/wiki/assets/js/20.a7a052f3.js"><link rel="prefetch" href="/wiki/assets/js/21.ac38f45c.js"><link rel="prefetch" href="/wiki/assets/js/22.0234a233.js"><link rel="prefetch" href="/wiki/assets/js/23.feb155c5.js"><link rel="prefetch" href="/wiki/assets/js/24.23579e7a.js"><link rel="prefetch" href="/wiki/assets/js/25.bf72279a.js"><link rel="prefetch" href="/wiki/assets/js/26.25fe7b51.js"><link rel="prefetch" href="/wiki/assets/js/27.32748c9b.js"><link rel="prefetch" href="/wiki/assets/js/28.2bd842a0.js"><link rel="prefetch" href="/wiki/assets/js/29.82c31a45.js"><link rel="prefetch" href="/wiki/assets/js/3.c2a01bbb.js"><link rel="prefetch" href="/wiki/assets/js/30.5c6bb128.js"><link rel="prefetch" href="/wiki/assets/js/31.12d6e431.js"><link rel="prefetch" href="/wiki/assets/js/32.d9fd8216.js"><link rel="prefetch" href="/wiki/assets/js/33.26b3025d.js"><link rel="prefetch" href="/wiki/assets/js/34.d3500f78.js"><link rel="prefetch" href="/wiki/assets/js/35.32652d97.js"><link rel="prefetch" href="/wiki/assets/js/36.d1c37690.js"><link rel="prefetch" href="/wiki/assets/js/37.2130f46d.js"><link rel="prefetch" href="/wiki/assets/js/38.1e0bb620.js"><link rel="prefetch" href="/wiki/assets/js/39.e33e3b77.js"><link rel="prefetch" href="/wiki/assets/js/4.1eed26ed.js"><link rel="prefetch" href="/wiki/assets/js/40.1d129165.js"><link rel="prefetch" href="/wiki/assets/js/5.adef3f68.js"><link rel="prefetch" href="/wiki/assets/js/6.3b848e60.js"><link rel="prefetch" href="/wiki/assets/js/7.1d469969.js"><link rel="prefetch" href="/wiki/assets/js/9.e5f31b9b.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.89cce7b1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><img src="/wiki/favicon.ico" alt="CS Wiki" class="logo"> <span class="site-name can-hide">CS Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  python
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/Linux/.html#" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><a href="/wiki/c/" class="nav-link">
  C
</a></div><div class="nav-item"><a href="/wiki/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/data-structure/" class="nav-link">
  数据结构
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  编译原理
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/wiki/tools/vim.html" class="nav-link">
  Vim
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/Makefile.html" class="nav-link">
  Makefile
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  shell
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  正则表达式
</a></li><li class="dropdown-subitem"><a href="/wiki/tools/git.html" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/wiki/Linux/.html#" class="nav-link">
  python
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="嵌入式" class="dropdown-title"><span class="title">嵌入式</span> <span class="arrow down"></span></button> <button type="button" aria-label="嵌入式" class="mobile-dropdown-title"><span class="title">嵌入式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/Linux/.html#" class="nav-link">
  x86汇编
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/sqlite3.html" class="nav-link">
  sqlite3
</a></li><li class="dropdown-item"><!----> <a href="/wiki/emebedded/stm32/" class="nav-link">
  stm32
</a></li></ul></div></div><div class="nav-item"><a href="https://chunni98.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/wiki/Linux/" aria-current="page" class="sidebar-link">Linux 笔记</a></li><li><a href="/wiki/Linux/learn-linux.html" aria-current="page" class="active sidebar-link">1 Linux 笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-1-gnu-c-complier" class="sidebar-link">1.1 GNU C Complier</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-2-动态链接库和静态链接库" class="sidebar-link">1.2 动态链接库和静态链接库</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-3-gnu-symbolic-debugger" class="sidebar-link">1.3 GNU  Symbolic Debugger</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-4-包管理工具-apt-和-dpkg" class="sidebar-link">1.4 包管理工具 apt 和 dpkg</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-5-输入输出重定向" class="sidebar-link">1.5 输入输出重定向</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-6-常用命令" class="sidebar-link">1.6 常用命令</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-7-elf-文件" class="sidebar-link">1.7 ELF 文件</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-8-常见服务" class="sidebar-link">1.8 常见服务</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-9-内核空间" class="sidebar-link">1.9 内核空间</a></li><li class="sidebar-sub-header"><a href="/wiki/Linux/learn-linux.html#_1-10-文件类型" class="sidebar-link">1.10 文件类型</a></li></ul></li><li><a href="/wiki/Linux/linux-collections.html" class="sidebar-link">2 Linux 问题集</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/wiki/Linux/unix-programing/" class="sidebar-heading clickable"><span>Unix 环境编程</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-1-gnu-c-complier"><a href="#_1-1-gnu-c-complier" class="header-anchor">#</a> 1.1 GNU C Complier</h2> <p>gcc/g++指令选项	功 能</p> <ul><li><code>-E</code>（大写）	预处理指定的源文件，不进行编译。</li> <li><code>-S</code>（大写）	编译指定的源文件，但是不进行汇编。</li> <li><code>-c</code>	编译、汇编指定的源文件，但是不进行链接。</li> <li><code>-o</code>	指定生成文件的文件名。</li> <li><code>-llibrary</code>	其中 library 表示要搜索的库文件的名称。该选项用于手动指定链接环节中程序可以调用的库文件。建议 -l 和库文件名之间不使用空格，比如 -lstdc++。</li></ul> <p>注意，使用-l选项指明静态库的名字时，既不需要lib前缀，也不需要.a后缀，只能写 test，GCC 会自动加上前缀和后缀。</p> <ul><li><code>-L &lt;path&gt;</code> 指定库路径。</li> <li><code>-I &lt;path&gt;</code> 指定头文件路径。</li> <li><code>-ansi</code>	对于 C 语言程序来说，其等价于 -std=c90；对于 C++ 程序来说，其等价于 -std=c++98。</li> <li><code>-std=</code>	手动指令编程语言所遵循的标准，例如 c89、c99、c++98、c++11 等。</li> <li><code>-D</code> 处理源文件前定义一个宏。</li> <li><code>-U</code> 取消宏定义。</li> <li><code>-g</code> 生成可调式文件。</li> <li><code>-O2</code> 比 <code>-O</code> 更好的优化编译。</li> <li><code>-MM</code> 查看文件的依赖（非标准库）</li> <li><code>Wall</code> 打开所有警告。</li> <li><code>Wextra</code> 启用一些未由-Wall启用的额外警告标志。</li> <li><code>Wvla</code> 警告动态数组的使用。</li> <li><code>Werror</code> 把所有的警告当作错误处理。</li> <li><code>static</code> 强制使用同名静态库，并且链接到的所有库都用静态编译。谨慎使用。</li> <li><code>-pedantic</code> 以ANSI/ISO C标准列出的所有警告，使用了扩展语法的地方将会产生警告。</li> <li><code>-ansi</code></li></ul> <p>链接指定的库：</p> <p><code>-l:libxxx.a</code> 或 <code>-l:libxxx.so.xxx</code></p> <h2 id="_1-2-动态链接库和静态链接库"><a href="#_1-2-动态链接库和静态链接库" class="header-anchor">#</a> 1.2 动态链接库和静态链接库</h2> <h3 id="_1-2-1-创建静态链接库"><a href="#_1-2-1-创建静态链接库" class="header-anchor">#</a> 1.2.1 创建静态链接库</h3> <p><code>ar rcs + 静态库文件的名字 + 目标文件列表</code></p> <p>如<code>ar rcs libtest.a *.o</code></p> <p>ar 是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件。ar 命令最常见的用法是将目标文件打包为静态链接库。</p> <p>对参数的说明：</p> <ul><li>参数 <code>r</code> 用来替换库中已有的目标文件，或者加入新的目标文件。</li> <li>参数 <code>c</code> 表示创建一个库。不管库否存在，都将创建。</li> <li>参数 <code>s</code> 用来创建目标文件索引，这在创建较大的库时能提高速度。</li> <li>参数 <code>v</code> 用</li> <li><code>d</code> 从归档文件中删除</li> <li><code>t</code> 查看归档文件的内容</li> <li><code>x</code> 解压归档文件</li> <li><code>a/b</code> 向归档文件中添加内容</li> <li><code>v</code> 显示详细信息</li></ul> <p><code>ar rcsv libxxx.a *.o</code></p> <h3 id="_1-2-2-创建动态链接库"><a href="#_1-2-2-创建动态链接库" class="header-anchor">#</a> 1.2.2 创建动态链接库</h3> <p><code>gcc 源文件(*.c) -c -fpic -Wall</code></p> <p><code>gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)</code></p> <p><code>-fPIC</code> 是创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。<code>-shared</code> 指定生成动态链接库。</p> <p>态库必须拷贝放在/usr/lib目录或/lib目录中，才可以使用。如果不想拷贝的话，可以在之前系统lib目录下生成一个动态库的软链接。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># 发布
 	1. 提供头文件: xxx.h
 	2. 提供动态库: libxxx.so
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>动态库如果安装在/lib或者/usr/lib下，那么 ld 默认能够找到</p> <p>或者将文件路径保存到 <code>/etc/ld.so.conf</code> 中。执行 <code>ldconfig</code> 命令，将 <code>/etc/ld.so.conf</code> 中保存的库路径写入 <code>/etc/ld.so.cache</code>。</p> <p><code>LD_LIBRARY_PATH</code> 环境变量保存库路径。</p> <p>ld.so 接口。</p> <p>静态库和动态库的载入时间是不一样的。</p> <p>静态库的代码在编译的过程中已经载入到可执行文件中，所以最后生成的可执行文件相对较大。</p> <p>动态库的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，所以最后生成的可执行文件相对较小。</p> <p>静态库和动态库的最大区别是，静态库链接的时候把库直接加载到程序中,而动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度。</p> <h2 id="_1-3-gnu-symbolic-debugger"><a href="#_1-3-gnu-symbolic-debugger" class="header-anchor">#</a> 1.3 GNU  Symbolic Debugger</h2> <p>TODO: 多线程调试。</p> <p>GDB调试主要有三种方式：</p> <p>直接调试目标程序：<code>gdb ./hello_server</code></p> <p>附加进程id：<code>gdb attach pid</code></p> <p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他，如果GDB attach某个进程，退出GDB之前要用命令 detach 解除附加进程。</p> <p>调试core文件：<code>gdb filename corename</code></p> <p>用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</p> <p><code>--core=COREFILE</code> 调试时core dump的core文件。</p> <p>gdb 内命令：</p> <p><code>list</code> 列出源文件，回车继续列出。</p> <p><code>break num</code> 在 num 行处设置断点。</p> <p><code>break funcname</code> 在函数入口处设置断点。</p> <p><code>break filename:funcname</code></p> <p><code>info break</code> 查看断点信息。</p> <p><code>run</code> 运行程序。</p> <p><code>next</code> 单条语句执行</p> <p><code>continue</code> 继续运行程序直到下一个断点。</p> <p><code>print</code> 查看变量当前的值。</p> <p><code>print param=value</code>，用于在调试过程中修改变量的值；</p> <p><code>print func()</code>，输出func函数执行的结果，常见的用途是打印系统函数执行失败原因：print strerror(errno)；</p> <p><code>ptype val</code> 打印变量类型。print type</p> <p><code>step</code> step in，如果有函数调用，他会进入该函数。</p> <p><code>next</code> step out，不会进入函数调用。</p> <p><code>bt</code> backtrace 查看函数堆栈。</p> <p><code>f n</code> frame 切换堆栈。</p> <p><code>return val</code> 命令是立即退出当前函数，剩下的代码不会执行了，return 还可以指定函数的返回值</p> <p><code>finish</code> 运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。</p> <p><code>watch expr</code> 设置观察点，<code>expr</code> 值变化时停住程序。<code>awatch expr</code> 当值被读或被写的时候停住程序。</p> <p><code>watch *指针变量</code>，监视的是指针所指的内容；</p> <p><code>clear</code> 清除所有停止点。<code>clear num</code> 清除指定行的停止点，<code>clear filenam:linenum</code> 清除指定文件指定行的停止点。</p> <p><code>disable [breakpoints] [range...]</code> 暂停所指定的停止点。</p> <p><code>enable [breadpoints] [range...]</code> 使能所有停止点。</p> <p><code>quit</code> 退出</p> <h2 id="_1-4-包管理工具-apt-和-dpkg"><a href="#_1-4-包管理工具-apt-和-dpkg" class="header-anchor">#</a> 1.4 包管理工具 apt 和 dpkg</h2> <h3 id="_1-4-1-软件源配置文件"><a href="#_1-4-1-软件源配置文件" class="header-anchor">#</a> 1.4.1 软件源配置文件</h3> <p><code>/etc/apt/sources.list</code></p> <p>软件源是指互联网中的众多服务器，这些服务器上存放了大量的软件包，可用于用户主机的更新和升级。</p> <h3 id="_1-4-2-apt-get"><a href="#_1-4-2-apt-get" class="header-anchor">#</a> 1.4.2 apt-get</h3> <p><code>apt-get</code> 用于管理软件包，包括安装、卸载、升级等。</p> <ul><li><code>update</code> 刷新软件源，下载更新软件包列表信息。</li> <li><code>upgrade</code> 将系统中所有软件包升级到最新版本。</li> <li><code>install</code> 下载所需软件包并进行安装配置。</li> <li><code>remove</code> 卸载软件包。</li> <li><code>autoremove</code> 将不满足依赖关系的软件包自动卸载。</li> <li><code>source</code> 下载源码包。</li> <li><code>clean</code> 删除缓存区中所有已下载的包文件。</li> <li><code>autoclean</code> 删除缓存区中老版本的已下载的包文件。</li> <li><code>check</code> 检查系统中依赖关系的完整性。</li> <li><code>--purge</code> 与 <code>remove</code> 一起使用，完全卸载软件包，同时删除该软件包所使用的配置文件。</li> <li><code>-s</code> 不做实际操作，只是模拟命令执行结果。</li> <li><code>-f</code> 修复系统中存在的软件包依赖性问题。</li></ul> <p><code>apt-get check</code> <code>apt-get -f install</code> 通常作为组合命令使用，前者用于检查软件包依赖关系，后者用于修复依赖关系。</p> <p>经常使用 <code>apt-get update</code> 刷新软件源可保持软件源最新。该命令会为服务器具有的软件包资源j</p> <p>查询安装包大小：<code>apt-cache show &lt;package&gt; | grep &quot;Size&quot;</code></p> <h3 id="_1-4-3-dpkg"><a href="#_1-4-3-dpkg" class="header-anchor">#</a> 1.4.3 dpkg</h3> <p><code>dpkg -r &lt;package&gt;</code> 移除一个已安装的软件包。</p> <p><code>dpkg -i &lt;package&gt;</code> 离线安装。</p> <p><code>dpkg -p &lt;package&gt;</code> 移除已安装软件包以及配置文件。</p> <p><code>dpkg -L &lt;package&gt;</code> 列出安装的软件包清单。</p> <p><code>dpkg-reconfigure &lt;package&gt;</code> 重新配置一个已安装的软件包。</p> <h2 id="_1-5-输入输出重定向"><a href="#_1-5-输入输出重定向" class="header-anchor">#</a> 1.5 输入输出重定向</h2> <p>标准输入 0，默认是键盘，标准输出 1，默认是终端，标准错误输出 2，默认是终端。</p> <p><code>command &lt; file</code> 将 <code>file</code> 重定向为输入源。</p> <p><code>command &gt; file</code> 将 <code>file</code> 重定向为输出源。</p> <p><code>command &gt;&gt; file</code> ，将 <code>file</code> 重定向为输出源，追加模式。</p> <p><code>command 2&gt; file</code> 将 <code>file</code> 重定向为标准错误源。</p> <p><code>command 2&gt;&gt; file</code> 将 <code>file</code> 重定向为标准错误源，追加模式。</p> <p><code>command &amp;&gt;&gt; file</code> 将 <code>file</code> 重定向为标准输出源和标准错误源，等同于 <code>&gt;&gt;&amp;</code> ，标准输出与标准错误输出全部重定向。</p> <p><code>command &gt;&gt; file1 2&gt;&gt; file2</code> 将 <code>file1</code> 重定向为标准标准输出源，将 <code>file2</code> 重定向为标准错误。</p> <p><code>command &gt; file1 2&gt;&amp;1</code> 将标准错误输出转成标准输出。</p> <p><code>&amp;&gt; /dev/null</code> 重定向到 <code>null</code>。</p> <p>输入输出重定向就是取代了键盘屏幕,能够接受键盘输入的都可以用重定向改为文件输入,能够输出到屏幕的,都可以通过重定向保存到文件。</p> <p>而管道符可以把标准输出转标准输入,以让可以接受标准输入的命令可以以此为输入执行命令,所以说,重定向也可以做到同样的事情,但一般来说不会这么做,就像cat,默认以文件名为参数,没有文件名才从标准输入读。</p> <p>定向的作用对象只能是文件。</p> <h2 id="_1-6-常用命令"><a href="#_1-6-常用命令" class="header-anchor">#</a> 1.6 常用命令</h2> <p>ls,cd,mv,cp,rm,mkdir,echo,date,pwd,clear,who,man,shutdown,passwd,su,top,pstree</p> <h3 id="_1-6-1-cat"><a href="#_1-6-1-cat" class="header-anchor">#</a> 1.6.1 cat</h3> <p><code>cat</code> 等待输入，按<code>&lt;enter&gt;</code> 键后输出到标准输出。</p> <p><code>cat &lt; file</code> 将file 的内容输出到标准输出。（默认是终端）</p> <p><code>cat &gt; file</code> 将输入的内容重定向到 file 中。</p> <h3 id="_1-6-2-less"><a href="#_1-6-2-less" class="header-anchor">#</a> 1.6.2 less</h3> <p>是一个分页显示工具。</p> <p><code>less</code> 命令主要用于打开大文件，<code>less</code> 不会读取整个文件，相比于 vim 或 nano 等文本编辑器，加载时间会更快。</p> <p><code>C-f</code> 翻页，<code>C-b</code> 翻页。</p> <p><code>-N</code> 打印行号。</p> <p><code>-m</code> 显示百分比。</p> <p><code>/&lt;pattern&gt;</code> 搜索 <code>&lt;pattern&gt;</code>，操作使用 <code>vi</code> 模式。<code>n</code>、<code>N</code>、<code>?</code> 。</p> <p><code>pa -aux | less</code></p> <h3 id="_1-6-3-wahtis"><a href="#_1-6-3-wahtis" class="header-anchor">#</a> 1.6.3 wahtis</h3> <p>等同于 <code>man -f</code> 。显示来自手册页的加简短说明(若有)。</p> <h3 id="_1-6-4-mount"><a href="#_1-6-4-mount" class="header-anchor">#</a> 1.6.4 mount</h3> <p>临时挂载分区</p> <h3 id="_1-6-5-umount"><a href="#_1-6-5-umount" class="header-anchor">#</a> 1.6.5 umount</h3> <p>卸载一个文件系统，就是从系统目录结构中，移去该指定的文件系统，卸载后的文件系统不能被用户使用。</p> <h3 id="_1-6-6-find"><a href="#_1-6-6-find" class="header-anchor">#</a> 1.6.6 find</h3> <h3 id="_1-6-7-du"><a href="#_1-6-7-du" class="header-anchor">#</a> 1.6.7 du</h3> <p>报告磁盘空间使用情况。</p> <p><code>-h</code> 以最常见的格式显示出大小。</p> <p><code>-T</code> 显示文件类型。</p> <h3 id="_1-6-8-df"><a href="#_1-6-8-df" class="header-anchor">#</a> 1.6.8 df</h3> <p>报告文件系统磁盘空间的使用情况。</p> <p><code>-T</code> 输出文件类型。</p> <p><code>-h</code> 以最常见的格式显示出大小。</p> <h3 id="_1-6-9-grep"><a href="#_1-6-9-grep" class="header-anchor">#</a> 1.6.9 grep</h3> <p><code>-n</code> 显示行号。</p> <p><code>-v</code> 改变匹配的意义，不显示匹配的行。通常配合使用：</p> <p><code>pa -aux | grep -n xxx | grep -v &quot;grep&quot;</code></p> <h3 id="_1-6-10-file"><a href="#_1-6-10-file" class="header-anchor">#</a> 1.6.10 file</h3> <p>查看文件类型。</p> <h3 id="_1-6-11-time"><a href="#_1-6-11-time" class="header-anchor">#</a> 1.6.11 time</h3> <p>多次执行一个脚本。</p> <p><code>time &lt;可执行文件&gt; [次数]</code></p> <p>输出每次重复操作(iteration)所需时间的平均值，以微秒为单位。测量时间使用流(elapsed)时间，而不是 CPU 时间。</p> <h3 id="_1-6-12-ls"><a href="#_1-6-12-ls" class="header-anchor">#</a> 1.6.12 ls</h3> <p>列出目录内容。</p> <p><code>-F</code> 目录显示 <code>/</code> 后缀。</p> <p><code>-l</code> 显示文件详细信息</p> <p><code>-a</code> 显示所有隐藏文件</p> <p><code>R</code> 递归显示子目录所有内容。</p> <p><code>i</code> 显示 <code>inode</code>。</p> <p><code>-h</code> 以最常见的格式显示出大小。</p> <p><code>-d</code> 查看目录自己的内容，而不是目录下的内容。</p> <p><code>ls -alrF</code>。</p> <h3 id="_1-6-13-tar"><a href="#_1-6-13-tar" class="header-anchor">#</a> 1.6.13 tar</h3> <p>7z 和 zip 压缩格式都不能保留 unix 风格的文件权限，比如解压出个可执行文件要重新 chmod chown 才能恢复正常。而 tar 格式可以。而 tar 本身不提供压缩，无非就是把包括所有文件的內容和权限拼成一个文件而己，所以用另外如 gzip 格式压缩。</p> <p>存储或提取 tar 文件的程序。</p> <p><code>-f</code> 指定存档或设备中的文件。</p> <p><code>-z</code> 用 <code>gzip</code> 处理文档。</p> <p><code>-x</code> 从文档提取文件。</p> <p><code>-c</code> 创建一个新的文档。</p> <p><code>-v</code> 显示文件处理过程。</p> <p><code>tar -xzvf</code> 解压 <code>tar.gz</code> 文件。</p> <p><code>tar -czvf</code> 压缩为 <code>tar.gz</code> 文件。</p> <p>xz 压缩效果最好，多线程压缩最快。</p> <p><code>tar -cvf &lt;压缩目标&gt; | xz -T 0 -c &gt; &lt;压缩包名&gt;.tar.xz</code> 或 <code>tar -I &quot;xz -T0&quot; -cvf &lt;压缩包名&gt;.tar.xz &lt;压缩目标&gt;</code></p> <h3 id="_1-6-14-chmod"><a href="#_1-6-14-chmod" class="header-anchor">#</a> 1.6.14 chmod</h3> <p>改变文件或目录的访问权限。</p> <h3 id="_1-6-15-chgrp"><a href="#_1-6-15-chgrp" class="header-anchor">#</a> 1.6.15 chgrp</h3> <p>改变文件或目录所属的组。</p> <h3 id="_1-6-16-ln"><a href="#_1-6-16-ln" class="header-anchor">#</a> 1.6.16 ln</h3> <p>在文件之间建立连接。</p> <p>默认建立硬链接。</p> <p><code>-s</code> 建立软链接。</p> <p>Linux 下的文件是通过索引节点（Inode）来识别文件，在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (Inode Number)。</p> <p>在 Linux 中，多个文件名指向同一索引节点是存在的，所以硬连接指通过索引节点来进行的连接，即每一个硬链接都是一个指向对应区域的文件。</p> <p>文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</p> <p>不能对目录创建硬链接。</p> <p><strong>硬链接的作用是允许一个文件拥有多个有效路径名</strong>，这样用户就可以建立硬链接到重要文件,有防止“误删”的功能。</p> <p>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个链接被删除后，文件的数据块及目录的连接才会被释放，也就是说，文件才会被真正删除。</p> <p><strong>软链接和源文件是两个不同的文件</strong>，支持跨文件系统建立。</p> <h3 id="_1-6-17-whereis"><a href="#_1-6-17-whereis" class="header-anchor">#</a> 1.6.17 whereis</h3> <p>查命令、源文件和man文件。</p> <p>locate the binary, source, and manual page files for a command。</p> <p><code>-b</code> 只搜索二进制。</p> <h3 id="_1-6-18-mkdir"><a href="#_1-6-18-mkdir" class="header-anchor">#</a> 1.6.18 mkdir</h3> <p><code>-p</code> 嵌套创建子目录。</p> <h3 id="_1-6-19-ps"><a href="#_1-6-19-ps" class="header-anchor">#</a> 1.6.19 ps</h3> <p>列出当前进程。</p> <p><code>-l</code> 查看当前终端的进程</p> <p><code>-ef</code> 以标准语法查看进程。</p> <p><code>-aux</code> 使用 BSD 语法查看进程。</p> <p><code>-le</code></p> <p><code>-axj</code> 查看所有守护进程</p> <p><code>-efj</code> 查看所有守护进程</p> <p>其中：</p> <ul><li><code>USER</code> 进程的启动者</li> <li><code>PID</code> 进程 ID</li> <li><code>%CPU</code> CPU 占用百分比</li> <li><code>%MEM</code> 内存占用百分比</li> <li><code>VSZ</code> 占用虚拟内存（swap空间）的大小</li> <li><code>RSS</code> 占用常驻内存（物理内存）的大小</li> <li><code>TTY</code> teel to you，终端，? 表示不需要终端或未知终端</li> <li><code>STAT</code> 进程状态：
<ul><li><code>D</code> 无法中断的休眠状态</li> <li><code>S</code> 休眠 sleep</li> <li><code>R</code> 运行</li> <li><code>Z</code> zombie ，僵死</li> <li><code>&lt;</code> 高优先级</li> <li><code>N</code> 低优先级</li> <li><code>s</code> 父进程</li> <li><code>+</code> 前台进程</li> <li><code>X</code> 死掉的进程</li> <li><code>L</code> 有些页被缩进内存</li> <li><code>l</code> 多线程，克隆线程。</li> <li><code>T</code> 停止或被追踪。</li></ul></li> <li><code>START</code> 启动改进程的时间</li> <li><code>TIME</code> 该进程占用 CPU 时间</li> <li><code>COMMAND</code> 启动该进程的命令的名称</li></ul> <h3 id="_1-6-20-kill"><a href="#_1-6-20-kill" class="header-anchor">#</a> 1.6.20 kill</h3> <p><code>kill [-signal] PID</code></p> <p>给指定进程发送指定信号. 如果没有指定信号, 则发送 TERM信号.  TERM 信号会杀死不能俘获该信号的进程.  对于其他进程,可能需要使用 KILL (9) 信号, 因为该信号不能够被俘获.</p> <p><code>SIGHUP</code> 1 终端在结束时，会给其下所有进程发送某个信号。对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</p> <p><code>SIGINT</code> 2 结束进程 <code>C-C</code></p> <p><code>SIGQUIT</code> 3 结束进程 <code>C-\</code></p> <p><code>SIGUSR1</code> 10 自定义</p> <p><code>SIGUSR2</code> 12 自定义</p> <p><code>SIGKILL</code> 9 杀死进程信号，不能不捕捉，不能被忽略、阻塞、注册。</p> <p><code>SIGALRM</code> 14 闹钟信号，定时器，当倒计时进程结束，结束进程</p> <p><code>SIGTERM</code> 15 终止信号。</p> <p><code>SIGHLD</code> 17 子进程结束，给父进程发送的信号</p> <p><code>SIGSTOP</code> 19 暂停进程，不能被捕捉信号，不能被忽略，不能被阻塞。</p> <p><code>SIGTSTP</code> 20 暂停进程，<code>C-Z</code></p> <h3 id="_1-6-21-chown"><a href="#_1-6-21-chown" class="header-anchor">#</a> 1.6.21 chown</h3> <p>修改文件所有者和组别。</p> <h3 id="_1-6-22-sync"><a href="#_1-6-22-sync" class="header-anchor">#</a> 1.6.22 sync</h3> <p>将内存的数据写回硬盘，并释放缓存。
Linux系统运行过程中，会有大量的临时数据驻留在内存缓存区，在关闭系统时需要将内存数据与硬盘数据进行同步校验，以保证系统数据不丢失。因此，通常sync命令是在关闭Linux系统前时使用。</p> <h3 id="_1-6-23-adduser"><a href="#_1-6-23-adduser" class="header-anchor">#</a> 1.6.23 adduser</h3> <p>添加用户。</p> <p>deluser 删除用户的同时删除用户的工作目录。</p> <p>delgroup 删除用户组。</p> <p><code>/etc/shadow</code>文件是加密的用户清单。</p> <p><code>/etc/passwd</code>文件是系统能够识别的用户清单。</p> <p><code>/etc/group</code> 文件包含了UNIX组的名称和每个组中成员列表。</p> <h3 id="_1-6-24-locate"><a href="#_1-6-24-locate" class="header-anchor">#</a> 1.6.24 locate</h3> <p>超快速查找任意文件。</p> <p>查找速度最快，但需要更新数据库。</p> <p><code>$ sudo updatedb</code></p> <p><code>-r</code> 使用正则表达式，如 <code>locate -r '\bls$'</code></p> <h3 id="_1-6-25-find"><a href="#_1-6-25-find" class="header-anchor">#</a> 1.6.25 find</h3> <p>功能最强大，但速度慢。</p> <h3 id="_1-6-26-grep"><a href="#_1-6-26-grep" class="header-anchor">#</a> 1.6.26 grep</h3> <p>打印匹配给定模式的行。</p> <p><code>grep [options] PATTERN [FILE]</code></p> <p>如 <code>grep enum /usr/include/*</code></p> <h3 id="_1-6-27-size"><a href="#_1-6-27-size" class="header-anchor">#</a> 1.6.27 size</h3> <p>指定输入文件各段及其总和的大小。（可执行文件、静态库、动态库、目标文件）</p> <h3 id="_1-6-28-strace"><a href="#_1-6-28-strace" class="header-anchor">#</a> 1.6.28 strace</h3> <p>跟踪可执行程序的系统调用。</p> <p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p> <p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。</p> <p>strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p> <h3 id="_1-6-29-nm"><a href="#_1-6-29-nm" class="header-anchor">#</a> 1.6.29 nm</h3> <p>nm 是name 的缩写，它显示指定文件中的符号信息，文件可以是对象文件、可执行文件或对象文件库。如果文件中没有包含符号信息，nm报告该情况，单不把他解释为出错。nm缺省情况下报告十进制符号表示法下的数字值。</p> <p><code>nm -C xxx.o</code></p> <h3 id="_1-6-30-umask"><a href="#_1-6-30-umask" class="header-anchor">#</a> 1.6.30 umask</h3> <p>Linux 不同，它是通过使用 umask 默认权限来给所有新建的文件和目录赋予初始权限的。</p> <p>root用户默认是0022，普通用户默认是 0002</p> <p>文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限</p> <p>umask -S 查看默认权限</p> <p>默认权限：文件 0777 - 0002 = 0755
目录 0666 - 0002 = 0644</p> <h3 id="_1-6-31-ldd"><a href="#_1-6-31-ldd" class="header-anchor">#</a> 1.6.31 ldd</h3> <p>命令可以查看一个可执行程序依赖的共享库。</p> <h3 id="_1-6-32-fg-bg-jobs"><a href="#_1-6-32-fg-bg-jobs" class="header-anchor">#</a> 1.6.32 fg,bg,jobs</h3> <p><code>jobs -l</code> 命令可以用来查看当前终端放入后台的工作</p> <p><code>fg %num</code> 命令用于把后台工作恢复到前台执行</p> <p><code>bg %num</code> 把后台暂停的工作恢复到后台执行</p> <h3 id="_1-6-33-nohub"><a href="#_1-6-33-nohub" class="header-anchor">#</a> 1.6.33 nohub,&amp;</h3> <p>nohup 不挂断地运行命令。no hangup的缩写，意即“不挂断”。命令的作用就是让后台工作在离开操作终端时，也能够正确地在后台执行。</p> <p>nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。</p> <p><code>nohup COMMAND &amp;</code> 这样就能使命令永久的在后台执行。</p> <h3 id="_1-6-34-netstat"><a href="#_1-6-34-netstat" class="header-anchor">#</a> 1.6.34 netstat</h3> <p>netstat -tunlp 用于显示 tcp，udp 的端口和进程等相关情况。</p> <p>netstat 查看端口占用语法格式：</p> <p>netstat -tunlp | grep 端口号</p> <ul><li><code>-t</code> (tcp) 仅显示tcp相关选项</li> <li><code>-u</code> (udp)仅显示udp相关选项</li> <li><code>-n</code> 拒绝显示别名，能显示数字的全部转化为数字</li> <li><code>-l</code> 仅列出在Listen(监听)的服务状态</li> <li><code>-p</code> 显示建立相关链接的程序名</li> <li></li></ul> <p>例如查看 8000 端口的情况，使用以下命令：</p> <p>netstat -tunlp | grep 8000</p> <p>tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      26993/nodejs</p> <p>更多命令：</p> <p>netstat -ntlp   //查看当前所有tcp端口</p> <p>netstat -ntulp | grep 80   //查看所有80端口使用情况</p> <p>netstat -ntulp | grep 3306   //查看所有3306端口使用情况</p> <h2 id="_1-7-elf-文件"><a href="#_1-7-elf-文件" class="header-anchor">#</a> 1.7 ELF 文件</h2> <p>ELF文件是一种用于二进制文件、可执行文件、目标代码、共享库和core转存格式文件。是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。</p> <p>elf 文件头，内部分段</p> <p>有三类文件属于 ELF 格式，</p> <ol><li>可执行文件</li> <li>目标文件。</li></ol> <p><code>readelf -a</code> 查看 <code>elf</code> 文件。</p> <p>1）可重定位文件（Relocatable File）</p> <p>包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据，即 xxx.o 文件。</p> <p>2）可执行文件（Executable File）</p> <p>包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像，即 a.out文件。</p> <p>3）共享目标文件（Shared Object File）</p> <p>包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像，即 xxx.so文件。</p> <p>4）内核转储(core dumps)</p> <p>存放当前进程的执行上下文，用于dump信号触发。</p> <p><img src="/linux/ELF%E6%A0%BC%E5%BC%8F.jpg" alt=""></p> <p><img src="/linux/ELF%E8%A7%86%E5%9B%BE.jpg" alt=""></p> <p>ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。</p> <p><code>objdump -D</code> 查看反汇编信息。</p> <p><code>objdump -S</code> 查看目标的汇编代码。</p> <h2 id="_1-8-常见服务"><a href="#_1-8-常见服务" class="header-anchor">#</a> 1.8 常见服务</h2> <p><code>/etc/init.d/ssh restart</code> 重启 <code>ssh</code> 服务。</p> <p><code>service sshd restart</code></p> <p><code>systemctl status tftpd-hpa</code> 查看服务状态。</p> <p><code>service tftpd-hpa status</code></p> <p><code>sshd</code> 服务，远程访问虚拟机服务。</p> <p><code>Samba</code> 服务，linux 和 windows 共享目录</p> <p><code>tftp</code> 服务，提供内核镜像 zImage 供 uboot 下载。</p> <p><code>nfs</code> 服务，提供网络文件系统。</p> <h2 id="_1-9-内核空间"><a href="#_1-9-内核空间" class="header-anchor">#</a> 1.9 内核空间</h2> <p><img src="/linux/%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84.png" alt=""></p> <p><img src="/linux/linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" alt=""></p> <h2 id="_1-10-文件类型"><a href="#_1-10-文件类型" class="header-anchor">#</a> 1.10 文件类型</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>文件类型	文件特点
普通文件	标识符 ‘-’ ，用open方式创建
目录文件	标识符 ‘d’ ，用mkdir方式创建
链接文件	标识符 ‘l’, ln -s 创建， 又可以分为软链接，硬链接
管道文件	标识   ‘p’， 用mkfifo创建
socket文件	标识符 ‘s’
字符设备文件	标识符 ‘c’
块设备文件	标识符 ‘b’
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>有名管道文件、字符设备文件、块设备文件、套接字(socket)文件不占磁盘空间。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">2023/4/3 11:54:21</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/Linux/" class="prev router-link-active">
        Linux 笔记
      </a></span> <span class="next"><a href="/wiki/Linux/linux-collections.html">
        2 Linux 问题集
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.e46b2869.js" defer></script><script src="/wiki/assets/js/2.4b7299de.js" defer></script><script src="/wiki/assets/js/8.530182c5.js" defer></script>
  </body>
</html>
